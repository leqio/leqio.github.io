## CSS

### 1. 设置文字渐变颜色

```css
.text {
	//background-image ：为该文字区域设置渐变背景色
	background-image: linear-gradient(to right, pink, purple);
	//将文字颜色设置成透明色
	color: transparent;
	//text 将背景裁剪成文字前景色，不支持ie
	-webkit-background-clip: text;
}
```

### 2. 图片img等比例缩放object-fit,配合object-position位置

```html
<div class="image-container">
  <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240918093621070.png" alt="image-20240918093621070" style="zoom:90%;" />
</div>

```

```css
.image-container {
  width: 300px;
  height: 200px;
  overflow: hidden;
}

img {
  width: 100%;
  height: 100%;
  object-fit: cover;           /* 确保图像覆盖容器 */
  object-position: 50% 0;      /* 水平居中，垂直对齐顶部 */
}
```



### 3. 调整span字符间距 letter-spacing

```css
span {
  font-weight: 200;
  font-size: 0.7rem;
  color: #FFFFFF;
  line-height: 1.38rem;
  letter-spacing: 1px; /* 调整字符间距 */
  text-align: center;
}
```

### 4. 位移动画 @keyframes

```css
// 定义动画
@keyframes jump-7f7e0456 {
  0% {
      transform: translateY(0);
  }
  25% {
      transform: translateY(-10%);
  }
  50% {
      transform: translateY(0);
  }
  75% {
      transform: translateY(10%);
  }
  100% {
      transform: translateY(0);
  }
}


.arrow-bottom-icon {
  animation: jump-7f7e0456 1.5s linear infinite;  /*设置动画*/
  width: 18px;
  height: 18px;
  cursor: pointer; /*鼠标变成手型*/
    /**
    *cursor : 用户鼠标指针的样式
属性值：
	none: 无
	default：默认光标（通常是一个箭头）
	auto：默认，浏览器设置的光标
	crosshair：光标为十字线
	pointer：光标为一只手
	move：光标为某对象可移动
	text：光标指示文本
	wait：光标指示程序正在忙（通常是一只表或者一个沙漏）
    */
    
}
```

### 5. 元素设置了position: relative

元素设置了position: relative;在设置top、left后该元素会偏移，但原来的位置还是保留的，不影响兄弟元素的位置，需要影响兄弟元素的话，不使用top,使用margin-top

### 6. 文字空两格text-indent: 2rem;
```css
.text-justified {
  text-align: justify; // 文本对齐，使其两端对齐
  text-justify: inter-ideograph; //针对中文字符的特殊设置，它会优化中文文本的排版，使字符之间的间距适当，避免字符之间过大的间隙
  white-space: pre-line; 这个属性会保留文本中的换行符 \n，并将其渲染为实际的换行，
}
```

### 7. css保持div宽高比aspect-ratio: 1;
```css
.element {
  width: calc(100% / 3);
  aspect-ratio: 1; /* 保持宽高比为 1:1 */
  height: auto; /* 高度自动调整 */
  overflow: hidden;/* 宽高比不对,强制关闭溢出 */
  margin-right: 0;
}

.streamers-item {
          width: calc((100% - 2.5rem) / 3);
          aspect-ratio: 1; 
          height: auto;
          margin-right: 1.25rem;

          &:nth-child(4n + 0) {
            margin-right: 1.25rem;
          }

          &:nth-child(3n + 0) {
            margin-right: 0;
          }
    }
```

### 8. 设置绝对路径absoult, 相对父元素居中

```css
top: 50%;
left: 50%;
transform: translate(-50%);
```

### 9. 设置四个字和两个字宽度一样，字体均匀分布

```css
.contact-bottom-title-list {  
              // display: inline-block;  
              width: 3.8rem;   
              text-align-last: justify;

              flex-basis: 3.8rem;     /* 确保基础宽度与设置的宽度相同 */
              flex-grow: 0;           /* 不允许增长 */
              flex-shrink: 0; 
            }  
```

### 10.文字多余设置省略号

```css
/* 单行文本设置省略号 */
        .text-single-line {
            display: block;
            overflow: hidden;
            text-overflow: ellipsis; /*适用于单行文本,与 white-space: nowrap; 配合使用*/
            white-space: nowrap;
        }

        /* 多行文本设置省略号 */
        /* 注意：在使用多行文本时，请保证所用字体的行高（line-height）和字体的字体大小（font-size）是相等的，否则会出现文字重叠 */
       .text {
        line-height: 1.5rem;
        font-size: 1.5rem;
        display: -webkit-box; /*配合 -webkit-line-clamp 多行文本截断*/
        -webkit-box-orient: vertical;  /* 必须指定方向为纵向 */
        overflow: hidden;
        -webkit-line-clamp: 3; /*指定显示的行数 -webkit-line-clamp 实际上会自带省略号的行为 */
       }
```

Safari浏览器中，如果文字设置了text-align: justify;  文字就会和省略号重叠问题。

出现这个 bug 的原因在于，这个省略号是自动生成的，在Safari下似乎没有受到文本两端对齐的作用，所以导致和文本发生了重叠， 貌似是忘记了对这个省略号进行对齐处理。

因此，如果这个省略号是自己定义的，本来就在页面中，当然就不会有这个问题了。

要实现超过指定行数出现省略号有几个实现点：

1. 超过指定行数截断文本
2. 右下角环绕的省略号
3. 在字数较少时自动隐藏省略号


### 11.引入外部字体并使用
```css
@font-face{
    font-family: 'HYk2gj';
    src : url('../fonts/HYk2gj.ttf');
}
div{
    font-family: 'HYk2gj';
}
```

### 12.flex布局，比例布局flex并设置间隙
```html
<div class="top-live">
    <div class="live-left"></div>
	  <div class="live-right"></div>
</div>
```

```css
/* 左右布局3:2 */
.top-live {
  display: flex;
  justify-content: space-between;
  gap: 1.25rem; // 设置间隙(纵向、横向)，相当于gap: 1.25rem 1.25rem;

  .live-left, .live-right {
    flex: 1; // 各占一半
  }
}
```

### 13.vue3使用v-html语法和::v-deep()穿透css样式
```html
1. 穿透到v-html的 .small-text,
<template>
  <div v-html="formatText(content)"></div>
</template>

<script setup>
comst content = '1234567，搭建微信生态全链路运营体系。组建人工智能研发团队';

// 处理v-html的文本内容
const formatText = (text) => {
  return text.replace('搭建微信生态全链路运营体系。','<span class="small-text" >搭建微信生态全链路运营体系</span>')
             .replace('组建人工智能研发团队', '<span class="small-text">组建人工智能研发团队</span>')
}
</script>

<style scoped lang="less">
  ::v-deep(.small-text) {
    font-size: 0.6rem;
    color: #666;
  }
</style>

2. 穿透到子组件的 .child-element, scoped 作用域不会默认穿透到子组件的 .child-element，::v-deep() 让它生效。
<template>
  <MyComponent />
</template>

<style scoped lang="less">
  /* 穿透到子组件的 .child-element */
  ::v-deep(.child-element) {
    fontSize: 30px;
  }
</style>
```

### 14.项目初始化css需要设置box-sizing
```css
*, *::after, *::before {
  box-sizing: border-box;
  margin: 0;
}

/* 注意，直接写 * { box-sizing: border-box; } 会影响所有html元素，但不会影响伪元素 */
::after 和 ::before 是伪元素， :hover是伪类
```

### 响应式设计屏幕适配方案
#### 一般情况下，对于手机，Ipad, 小屏幕PC端，中等屏幕PC端，大屏幕PC端，大屏，设置根字体大小1rem是多少px？
```css
html {
  font-size: 16px; /* 默认 */
}

@media (min-width: 768px) {
  html {
    font-size: 18px; /* iPad */
  }
}

@media (min-width: 1024px) {
  html {
    font-size: 18px; /* 小屏幕 PC */
  }
}

@media (min-width: 1280px) {
  html {
    font-size: 20px; /* 中等屏幕 PC */
  }
}

@media (min-width: 1600px) {
  html {
    font-size: 22px; /* 大屏幕 PC */
  }
}

@media (min-width: 1920px) {
  html {
    font-size: 24px; /* 超大屏幕 */
  }
}

```

在设计响应式布局时，通常会根据不同设备和屏幕大小来设置根字体大小（1rem）。以下是一些常见设备和屏幕大小的根字体建议：
1. 手机（小屏幕）
    屏幕宽度：小于 768px（如手机）
    根字体大小建议：16px
    1rem = 16px
    在这种情况下，1rem 通常等于 16px，因为大多数手机的默认字体大小是 16px。
2. iPad（中小屏幕平板）
    屏幕宽度：768px 至 1024px
    根字体大小建议：16px 到 18px
    1rem = 16px 到 18px
    对于 iPad 和类似大小的设备，通常保持 16px 或者稍微增加到 18px，这样可以保证文本的可读性。
3. 小屏幕 PC端
    屏幕宽度：1024px 到 1280px
    根字体大小建议：16px 到 18px
    1rem = 16px 到 18px
    对于小屏幕 PC，通常也会选择 16px 或 18px 作为根字体大小，保持良好的可读性。
4. 中等屏幕 PC端
    屏幕宽度：1280px 到 1600px
    根字体大小建议：18px 到 20px
    1rem = 18px 到 20px
    对于中等屏幕的桌面设备，可以适当增加根字体大小，比如使用 18px 或 20px。
5. 大屏幕 PC端
    屏幕宽度：1600px 到 1920px
    根字体大小建议：20px 到 22px
    1rem = 20px 到 22px
    在大屏幕 PC 上，根字体大小可以增加到 20px 或 22px，确保文字清晰可读。
6. 超大屏幕（大屏电视/显示器）
    屏幕宽度：1920px 以上
    根字体大小建议：22px 以上
    1rem = 22px 或更大
    在大屏幕显示器上，尤其是在用于展示网页的电视或超大显示器上，根字体大小可以设置为 22px 或更大，以确保内容清晰。
总结：
    小屏幕设备（手机和小型平板）：根字体大小设置为 16px。
    中型设备（iPad 和较小的 PC）：根字体大小可以设置为 16px 到 18px。
    大屏幕 PC 设备：根字体大小可以设置为 18px 到 22px。
    超大屏幕设备：根字体大小可以设置为 22px 及以上。



#### PC适合H5屏幕适配方案 @media媒体查询 + 插件postcss-pxtorem
两种方案效果一致。都会实现响应式设计，使得页面在不同屏幕尺寸下自适应。
方案一的实现更加简洁和自动化，适合自动调整根字体大小，而方案二则适合对不同屏幕尺寸进行精细控制，具有更多的手动设置。

方案一：postcss-pxtorem动态设置根字体大小
方案二：postcss-pxtorem设置默认根字体大小 + 媒体查询设置不同屏幕根字体大小 

方案二中：
```js
html {
  font-size: 16px; /* 默认根字体为 16px */
}

@media screen and (min-width: 1920px) {
  html {
    font-size: 18px; /* 1920px 屏幕时根字体大小变为 18px */
  }
}
且设置
postcssPxtorem({
  rootValue: 16,  // 默认根字体为 16px
  propList: ['*'], // 所有 CSS 属性都转换为 rem
  mediaQuery: true, // 媒体查询中也进行转换
})，
在.content-container { width: 1020px;  height: 10rem}
则.content-container在1920屏幕中实际宽高是多少px？

postcss-pxtorem先根据自己的根字体16px,将width: 1020px;  height: 10rem 转换成rem: {width: 63.75rem;  height: 10rem},
然后媒体查询@media将根字体换成18px,
浏览器最终根据根字体的大小将 rem 转回 px 进行页面渲染。
也就是在1920屏幕中实际宽高是{width: 1147.5px;  height: 180px}
```


**方案一：**
```js
/* vite.config.js  */
export default defineConfig({
  css: {
    // px自动转换rem插件配置
    postcss: {
      plugins: [postCssPxToRem({
          rootValue: (file) => {
            // 动态设置 rootValue，根据屏幕宽度或某些条件来调整
            if (window.innerWidth >= 1920) {
              return 21.33;  // 1920px 屏幕时，根字体大小为 21.33px
            } else if (window.innerWidth >= 1440) {
              return 16;  // 1440px 屏幕时，根字体大小为 16px
            } else if (window.innerWidth >= 1024) {
              return 14;  // 1024px 屏幕时，根字体大小为 14px
            } else {
              return 16;  // 默认使用 16px
            }
          },
          propList: ['*'],
          replace: true,
          mediaQuery: false,
          minPixelValue: 2,
          exclude: /node_modules/
      })]
    }
  },
})
```


**方案二：**
1. @media媒体查询适配
设置一个根元素的基准值，这个基准值通常根据视口宽度进行计算。可以在项目的 CSS 文件中，通过媒体查询动态调整根元素的 font-size。
```css
html {
  font-size: 16px; /* 默认基准值，在这里，小于1024px的屏幕根字体大小为16px */
}

...
@media (min-width: 1024px) {
  html {
    font-size: 14px; /* 适配较大屏幕 */
  }
}
@media (min-width: 1440px) {
  html {
    font-size: 16px; /* 适配超大屏幕 */
  }
}
@media (min-width: 1920px) {
  html {
    font-size: 21.33px; /* 适配超大屏幕 */
  }
}
```

2. 使用 PostCSS 插件 postcss-pxtorem 转换 px 为 rem， 注意版本(可选择v6.1.0及以上)
- 安装插件
npm install postcss-pxtorem --save-dev

- 项目根目录新建文件postcss.config.js
```js
/* postcss.config.js  */
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 16, // 基准值，对应于根元素的 font-size
      unitPrecision: 5, // 保留小数点位数
      propList: ['*', '!min-width', '!max-width'], // 需要做转化处理的属性，*表示全部，排除 min-width 和 max-width 属性
      selectorBlackList: ['.ignore'], // 忽略选择器：不希望转换类名.ignore的样式
      replace: true, // 替换而不是添加备用属性
      mediaQuery: true, // 允许在媒体查询中转换 px
      minPixelValue: 0 ,// 最小的转换数值
      exclude: /node_modules/
    }
  }
};
/* vite.config.js  */
export default defineConfig({
  css: {
    postcss: './postcss.config.js',
  }
})


或者直接在vite.config.js里设置：
/* vite.config.js  */
export default defineConfig({
  css: {
    // px自动转换rem插件配置
    postcss: {
      plugins: [postCssPxToRem({
          rootValue: 16,
          propList: ['*'],
          replace: true,
          mediaQuery: false,
          minPixelValue: 2,
          exclude: /node_modules/
      })]
    }
  },
})

```

3. CSS/SCSS/LESS 中使用 px
```css
.container {
  width: 320px;
  padding: 16px;
}
 
.header {
  height: 64px;
  margin-bottom: 24px;
}
```

4. 通过构建工具（如 webpack/vite ）运行项目时，PostCSS 插件会自动将 px 转换为 rem

5. 可以不用@media媒体查询，动态动态调整font-size
为了实现更动态的适配，可以通过 JavaScript 动态设置根元素的 font-size：
```js
/*utils/setRootFontSize.js 文件*/
function setRootFontSize(): void {
     const docEl = document.documentElement;
     const clientWidth = docEl.clientWidth;
     if (!clientWidth) return;
     const baseFontSize = 16; // 基准字体大小
     const designWidth = 1920; // 设计稿宽度
     docEl.style.fontSize = (baseFontSize * (clientWidth / designWidth)) + 'px';
   }
export default setRootFontSize;
 

/**APP.jsx文件中使用 动态设置根元素的字体大小**/
import setRootFontSize from '../utils/setRootFontSize.js';
import { useEffect } from 'react';
 
export default function App() {
  useEffect(() => {
    // 设置根元素的字体大小
    setRootFontSize();
    // 窗口大小改变时重新设置
    window.addEventListener('resize', setRootFontSize);
    // 清除事件监听器
    return () => {
      window.removeEventListener('resize', setRootFontSize);
    };
  }, []);
  
  return (
    <>
      <div>
        <MyRoutes />
      </div>
    </>
  )
}
```


##### 下面是一套在实际开发中，兼容性较好的实践代码：
```js
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<style>
		html {
		    font-size: 16px;
		}
		 
		@media screen and (min-width: 375px) {
		    html {
		        /* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */
            {/*设计时确定的一个比例: / 39 是为了将屏幕宽度的差值按一个合适的比例进行划分，确保字体增大的速度平滑,
            * 2 是为了加倍这个差值，增加字体变化的速率，使得随着屏幕宽度的增加，字体增大更加明显。 */}
		        font-size: calc(100% + 2 * (100vw - 375px) / 39);
		        font-size: calc(16px + 2 * (100vw - 375px) / 39);
		    }
		}
		@media screen and (min-width: 414px) {
		    html {
		        /* 414px-1000px每100像素宽字体增加1px(18px-22px) */
            {/* 112.5% 相当于初设font-size 16px的112.5%倍，也就是18px */}
		        font-size: calc(112.5% + 4 * (100vw - 414px) / 586);
		        font-size: calc(18px + 4 * (100vw - 414px) / 586);
		    }
		}
		@media screen and (min-width: 600px) {
		    html {
		        /* 600px-1000px每100像素宽字体增加1px(20px-24px) */
		        font-size: calc(125% + 4 * (100vw - 600px) / 400);
		        font-size: calc(20px + 4 * (100vw - 600px) / 400);
		    }
		}
		@media screen and (min-width: 1000px) {
		    html {
		        /* 1000px往后是每100像素0.5px增加 */
		        font-size: calc(137.5% + 6 * (100vw - 1000px) / 1000);
		        font-size: calc(22px + 6 * (100vw - 1000px) / 1000);
		    }
		}
	</style>
	<body>
		<div style="font-size: 1.0rem;">我是16px</div>
		<div style="font-size: 1.125rem;">我是18px</div>
	</body>
</html>

```







## HTML


## JS

### 1. 滚动导航方法 Element.scrollIntoView()

```js
const companyProfile = ref(null)
const handleDecline = () => {
  companyProfile.value.scrollIntoView({
    behavior: 'smooth', // 平滑滚动效果
    block: 'start',     // 垂直方向上元素的顶部对齐到视口顶部
    inline: 'nearest'   // 水平方向保持就近对齐
  });
};

```

### 2. js获取父节点
```js
  let swiperBoxEl = event.target;
  let swiperItemEl = event.currentTarget.parentNode;
  let imgEl = swiperBoxEl.querySelector('img');
  let nameEl = swiperItemEl.querySelector('.name');

  swiperItemEl.style.width = "35rem";
  imgEl.style.borderRadius = '1.25rem 0 0 1.25rem';
  nameEl.style.display = 'none';
```

```css
&:hover {
  width: 38rem;

  .swiper-def-box {

    img {
      border-radius: 1.25rem 0 0 1.25rem;
    }

    .name {
      display: none;
    }
  }
}
```

### 3. js 静态引入资源路径和动态引入资源路径
import静态引入：
```js
import douyu from '../assets/斗鱼@2x.png';
const partnerList = ref([
  douyu
]);
```

动态路径引入：
new URL(‘’，import.meta.url).href   把相对路径解析为图片的绝对路径
```js
const imgSrc = new URL(`../assets/images/icon@${window.devicePixelRatio > 1 ? '2x' : '1x'}.png`, import.meta.url).href;

// const cdnBaseUrl = userLocation === 'US' ? 'https://cdn-us.example.com/' : 'https://cdn-eu.example.com/';
// const imgSrc = `${cdnBaseUrl}assets/images/banner.png`;

const partnerList = ref([
  imgSrc
]);
```

### 4.pinia中，使用storeToRef()解构store
主要用于在模板template中使用解构后的值，js中最好用`fileStore.fileList`调用，

storeToRef()解构后是ref，依赖于 Vue 的响应系统，在别的组件修改了fileStore.fileList的值后，这个组件的fileList可能还没有被同步更新，js中打印还是旧值；

但如果这个组件中修改ref值后立即打印ref,会是最新的值。

`fileStore.fileList` 是通过 `Proxy` 代理的，直接更新。

如何确保解构后的 `ref` 被及时更新？

1.通过 `nextTick` 确保更新，确保DOM已渲染后才执行里面的回调函数
```js
nextTick(() => {
  console.log('nextTick 解构后的 fileList:', fileList.value); // 现在 fileList.value 是 更新的
});
```

2.`watch` 监听
```js
watch(fileList, (newValue) => {
  console.log('fileList 更新为:', newValue);
});
```

### 5. this指向
箭头函数没有自己的this，箭头函数的 this 会指向 上一级作用域 的 this，而不是指向调用它的对象
普通函数的 this 会指向指向调用它的对象，默认windows

// 添加动态属性名， 相当于this.button1 = btn;
this['button' + id] = btn; 

### 6.export和import语法
从其他模块导出变量：
export { URL } from 'some-module';
等价于：
import { URL } from 'some-module';
export { URL };


默认导出变量：export default URL;
错误写法：export default URL from 'some-module' ;
正确写法：
import URL from 'some-module';
export default URL;


### 7. .replace()用法
.replace(searchValue, replaceValue)，
    searchValue：可以是一个字符串，表示要查找的内容，也可以是一个正则表达式，用于更复杂的匹配。
    replaceValue：可以是一个字符串，表示替换后的内容，也可以是一个函数，用于动态生成替换内容。
    返回值：返回一个新的字符串，其中匹配的部分被替换为新的内容，不改变原字符串。

```js
// 1.3 定义匹配<style></style>标签正则，/s空白字符，/S非空白字符，*匹配任意次
const regStyle = /<style>[\s\S]*<\/style>/
// 1.4 定义匹配<script></script>标签正则，/s空白字符，/S非空白字符，*匹配任意次
const regScript = /<script>[\s\S]*<\/script>/

const newHTML = htmlStr
        .replace(regStyle, '<link rel="stylesheet" href="./index.css" />')
        .replace(regScript, '<script src="./index.js"></script>'); 

```


## vue

### 自动导入elementPlus组件和图标：
npm i unplugin-auto-import unplugin-vue-components unplugin-icons -D
npm i element-plus @element-plus/icons-vue

vite.config.js配置
```js
import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// Element-icon自动导入
import Icons from 'unplugin-icons/vite'
import IconsResolver from 'unplugin-icons/resolver'
// Element自动导入
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'
// px自动转rem
import postCssPxToRem from 'postcss-pxtorem'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      resolvers: [
        ElementPlusResolver(),
        // 自动导入图标组件
        IconsResolver({
          prefix: 'Icon',
        }),
      ],
    }),
    Components({
      resolvers: [
        ElementPlusResolver(),
        // 自动注册图标组件
        IconsResolver({
          enabledCollections: ['ep'],
        }),
      ],
    }),
    Icons({
      autoInstall: true,
    }),
  ],
  resolve: {
    // 设置路径别名
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  css: {
    // px自动转换rem插件配置
    postcss: {
      plugins: [
        postCssPxToRem({
          rootValue: 16,
          propList: ['*'],
          replace: true,
          selectorBlackList: [], // 需要忽略的选择器
          unitPrecision: 5, // 转换后保留的小数位数
          mediaQuery: false,
          minPixelValue: 2,
          exclude: /node_modules/
        })
      ]
    }
  },
})

```
**使用方法：**
不用手动导入组件，直接使用： element组件和图标，
注意图标：官网上是`<el-icon ><Moon /></el-icon>`,不可用，
要使用i-ep做前缀才有用：`el-icon size="50" color="#000"><i-ep-moon /></el-icon>`
```html
<template>
  <el-container>
      <el-header>
        <div class="content-container">
          <div class="home-header">
            <div class="title">
              <div class="title-icon">⌘</div>
              <div class="title-name">CmdPro</div>
            </div>
            <div class="switch-theme">
              <el-icon size="50" color="#000"><i-ep-moon /></el-icon>
            
            </div>
          </div>
        </div>
        <div class="line"></div>
      </el-header>
  </el-container>
</template>

<script>

</script>

<style lang="less" scoped>

</style>
```


### 实现切换主题
1. index.html上html元素添加自定义属性 data-theme="light"
```html
<!doctype html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

2. 新建主题css文件 theme.css
```css
/* 暗色主题 */
html[data-theme = 'dark'] {
    --text-color: #fff;
    --bgl: #102118;
    --bg2: #2d5567;
}

/* 默认亮色主题 */
:root {
    --text-color: #333;
    --bgl: #c7ffdd;
    --bg2: #fbd988;
}
```

3. utils工具文件夹下新建useTheme.js
```js
import {ref, watchEffect} from 'vue';

// 初始化主题为 light
const theme = ref('light');

// 1.watchEffect()传入的函数默认会直接被执行
// 2.在执行的过程中, 会自动的收集依赖(依赖哪些响应式的数据): 这里监听到 theme.value
watchEffect(() => {
  // document.documentElement 指的是 HTML 文档的根元素，即 <html> 标签
  // setAttribute 方法用于给 HTML 元素添加或修改属性。
  // 这里的 'data-theme' 是一个 自定义属性，可以用来存储当前主题模式
    document.documentElement.setAttribute('data-theme', theme.value);
})

/**切换主题*/
export function useTheme() {
    // 切换方法
    function toggleTheme() {
        theme.value = theme.value === 'light' ? 'dark' : 'light';
    };

    return { theme, toggleTheme};
}
```

4. Home.vue中使用theme切换主题
```html
<template>
  <div class="home">
    <div class="switch-theme" :class="theme" @click="toggleTheme">
      <span>{{theme}}</span>
      <span>{{theme === 'light' ? '亮色' : '暗色'}}主题</span>
      <el-icon size="20" :color="theme === 'light' ? '#000' : '#ddf'">
        <component :is="theme === 'light' ? Sunny : Moon" />
      </el-icon>
    </div>
  </div>
</template>

<script setup>
import { Moon, Sunny } from '@element-plus/icons-vue';
import { ref, reactive, computed} from 'vue';
import {useTheme} from '@/utils/useTheme.js';

//#region 切换主题
const {theme, toggleTheme} = useTheme();
//#endregion 切换主题

</script>

<style lang="less" scoped>
  @import './home.less';
  
</style>
```


## 其他

### 1. favicon.icon图标更新却没有变化

需要清除浏览器缓存后刷新页面。

### 2. 图片懒加载插件vue3-lazyload

参考文章：https://blog.csdn.net/weixin_43288600/article/details/132239842

1. 安装图片懒加载插件：npm i vue3-lazyload

2. main.js文件中，

   ```js
   //引入图片懒加载插件
   
   import Lazyload from "vue3-lazyload";
   
   app.use(Lazyload, {
       loading: "../src/assets/images/default.gif",//可以指定加载中的图像
       error: "../src/assets/images/err.png",//可以指定加载失败的图像
    });
   ```

   3.组件中使用图片懒加载

   ```vue
   <template>
   <!-- 方法1-->
   	<img class="live2" v-lazy="business1" :key="activities2" alt="">
   <!-- 方法2-->
   	<img v-lazy="{ src: '../src/assets/全面关爱@2x.png'}">
   </template>
   
   <script setup>
       import business1 from '../assets/娱乐直播@2x.png';
   </script>
   ```


​	方法2在开发环境不报错，上传至服务器路径加载失败，没找到原因

### 3.使用elementUI的Carousel 走马灯组件

参考：https://element-plus.org/zh-CN/guide/quickstart.html
安装 npm install element-plus --save

```js
// main.js

import { createApp } from 'vue'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import * as Icons from '@element-plus/icons'
import App from './App.vue'

const app = createApp(App)

app.use(ElementPlus)
app.mount('#app')
```



```vue
<el-carousel indicator-position="">
  <el-carousel-item v-for="item in activityList" :key="item">
        <img v-lazy="item.url" :key="item.url" alt="">
        <div class="text">
          <div class="text-name">{{ item.name }}</div>
          <div class="text-roomid">
            <span>斗鱼ID：</span>
            <span class="num-font">{{ item.roomid }}</span>
          </div>
        </div>
  </el-carousel-item>
</el-carousel>
```



### 4.解决浏览器页面缩放，网页内容变形问题：

```css
// 浏览器网页比例缩小网页不变形，外层元素直接设置固定宽度  .content { width: 90rem}
  @media screen and (min-width: 1700px) {
    .home {
      display: flex;
      width: 90rem;
      flex-direction: column;
      justify-content: center;
      margin: 0 auto;

      .header-box {
        margin: 0 auto;
      }
    }
  }
```

### 5.实现首页大图逐帧加载（还没研究）



### 6.后台报错找不到图片路径问题（打包后没有该图片）

办法：将图片放到public下，public文件夹直接被打包



### 7.github在线运行项目，在网站github前面加 gitpod.io/#/

### 8.页面加载优化方式

#### 1.nginx参数设置

1. **启用 Gzip 压缩**
启用 Gzip 压缩可以显著减少传输的数据量，从而加快页面加载速度。
```nginx
http {
    
    gzip on; # 启用 gzip 压缩
	gzip_comp_level 6; # 压缩级别，范围 1-9，数字越大，压缩率越高但占用更多 CPU 
	gzip_min_length 1k;       # 超过 1KB 的响应才进行压缩
	gzip_buffers 32 4k;       # 分配 32 个 4KB 缓冲区用于压缩
	# 启用 gzip 对响应的 HTTP 头部 `Vary: Accept-Encoding`
	# 这个设置允许代理服务器根据客户端支持的编码方式正确缓存响应
    gzip_vary on;
    gzip_static on; # 启用静态压缩
	gzip_proxied any;# 允许对所有来自代理服务器的请求进行 Gzip 压缩，无论请求中是否包含特定的缓存控制头部。
	gzip_http_version 1.1;# 限制 Gzip 压缩仅用于 HTTP/1.1 及以上版本的请求，确保与现代浏览器和客户端兼容
	# 指定需要进行 gzip 压缩的文件类型
	gzip_types
		text/plain              # 纯文本文件
		text/css                # CSS 文件
		text/javascript         # 早期的 JavaScript MIME 类型
		application/javascript  # 现代的 JavaScript 文件类型
		application/x-javascript# 另一个 JavaScript 文件类型
		application/json        # JSON 文件
		application/xml         # XML 数据
		text/xml                # XML 文本文件
		application/xml+rss     # RSS XML 文件
		image/svg+xml         # SVG 图像（矢量图形，文本形式）
		image/jpeg
		image/png
		image/gif
		image/webp;
	# 禁止压缩 HTTP 响应代码为 400 及以上的请求（如错误页面）
	gzip_disable "msie6";  # 禁用对 IE6 的 gzip 支持，因为它存在一些 gzip 相关的兼容性问题
}
```
查看gzip压缩： 先清除浏览器缓存

方法一：打开开发者工具（按F12）,转到NetWork选项卡，刷新页面（按F5）,点击一个css文件，在Header中，查看Response Header中的Content-Encoding，如果有 Content-Encoding: gzip，那么该文件已经被压缩。

方法二：命令行，使用curl命令直接请求 CSS 文件并检查响应头，输入要查看要压缩的文件地址

```cmd
curl -I -H "Accept-Encoding: gzip" http://yourwebsite.com/path/to/your.css

```



2. **设置缓存**
使用缓存可以减少服务器的负担，提高响应速度。
- **设置静态文件缓存**：
```nginx
location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff|woff2|ttf|svg)$ {
    expires 30d;  # 设置缓存时间为30天
    add_header Cache-Control "public, max-age=2592000";  # 2592000秒=30天
}
```

3. **启用 HTTP/2**
HTTP/2 可以通过多路复用、头部压缩等技术提高页面加载速度。
```nginx
server {
    listen 443 ssl http2;
    server_name your_domain.com;
    ...
}
```

4. **使用 Content Delivery Network (CDN)**
通过 Nginx 配置 CDN 以减少延迟和提高下载速度。
```nginx
location / {
    proxy_pass https://your_cdn_url;
    proxy_set_header Host $host;
}
```

5. **连接优化**
配置 Nginx 的连接数和超时，以提高并发性能。
```nginx
http {
    keepalive_timeout 65;  # 长连接保持时间
    client_body_timeout 12;  # 客户端请求体超时时间
    client_header_timeout 12;  # 客户端请求头超时时间
}
```

6. **设置合理的文件上传限制**
```nginx
client_max_body_size 10M;  # 设置最大上传文件大小为10MB
```

7. **使用异步处理**
通过 `worker_processes` 和 `worker_connections` 配置，优化处理能力。
```nginx
worker_processes auto;  # 自动设置工作进程数量
events {
    worker_connections 1024;  # 每个进程最大连接数
}
```

8. **优化日志**
减少日志记录的详细程度，可以减少 I/O 操作，提升性能。
```nginx
http {
    access_log /var/log/nginx/access.log combined;  # 修改为简化的日志格式
    error_log /var/log/nginx/error.log warn;  # 只记录警告及以上级别的错误
}
```

9. 对于 CSS、JS 和图片等资源，使用合并和最小化工具，减少 HTTP 请求数量，降低加载时间。

总结
通过以上 Nginx 参数设置，可以有效地提升页面加载速度，优化用户体验。根据你的实际情况进行相应的配置，以实现最佳效果。配置完毕后，建议使用网站性能测试工具（如 PageSpeed Insights、GTmetrix）评估优化效果，并根据反馈继续调整。

#### 2.图片压缩：

https://juejin.cn/post/7081470790494847013

JPG格式：有损压缩` `体积小` `加载快` `不支持透明；适用于呈现色彩丰富的图片，经常作为 **大的背景图、轮播图或 Banner 图**

PNG-8与PNG-24格式：无损压缩` `质量高` `体积大` `支持透明；适用于呈现 **小的 Logo、颜色简单且对比强烈的图片或背景等**

SVG格式：文本文件` `文件体积更小` `可压缩性更强；适合响应式设计和不同分辨率的设备 | [在线矢量图库](https://link.juejin.cn/?target=https%3A%2F%2Fwww.iconfont.cn%2F)

Base64编码：作为小图标解决方案

WebP格式：支持透明度` `支持动图，且文件体积更小；浏览器兼容性较差，特别是在某些旧版浏览器上

1. **目标文件大小**

​	对于大多数网站来说，以下是一个常见的压缩大小参考：

​	**小图标和图像**（如 UI 图标、按钮图）：文件大小应在 **10-50KB** 之间。

​	**中等大小的图片**（如小型展示图片或头像）：文件大小应在 **50-150KB** 之间。

​	**大图片**（如横幅、产品图片、背景图等）：文件大小最好控制在 150-300KB之间。

​	如果图像非常大（超过 2000px 宽），可以接受 **300-500KB** 的大小，但要避免更大尺寸以免影响加载速度。

2.**图片分辨率**

​	普通网页内容**：一般图片的分辨率可以设置为 **72 DPI**，这是显示器常见的分辨率。没有必要使用更高的分辨率，因为显示器不会显示更高的细节。

​	**高分辨率设备（如 Retina 屏幕）**：可以考虑为这些设备提供 **2x 或 3x 大小的图片**，但需要优化以防文件太大。可以利用响应式图像（`srcset`）机制为不同	设备加载不同分辨率的图片。

3.**图片格式选择**

- **WebP**：一般可以压缩到原图文件的 **25%-50%**，但仍能保持较好的视觉质量。适用于大多数场景。

- **JPEG**：适用于有损压缩，照片类图片效果好，建议压缩质量设置在 **70-85%** 之间。

- **PNG**：无损格式，适合需要透明背景的图片。使用无损压缩工具（如 `tinypng`）压缩后，文件大小可以减小 **50% 以上**。

- **SVG**：矢量图（如图标、简洁的线条图），通常文件大小非常小，可以直接使用，避免过度优化。

4.**压缩质量设置**

- **JPEG/WEBP 压缩质量**：通常设置在 **70-85** 之间。这段范围可以在保持良好视觉效果的同时显著减少文件大小。如果图片不涉及细节的清晰度（如背景图），可以降低到 60-70。

- **PNG 无损压缩**：使用工具如 `tinypng`、`ImageOptim` 等，通常可以减小文件大小 40-60%。

5.**自动化工具和流程**

​	建议使用自动化工具和构建流程进行图片压缩：

- **TinyPNG、ImageOptim**：手动压缩图片，适合小规模图片优化。
- **Webpack/Vite + imagemin 插件**：在开发流程中自动压缩图片，适合项目内大规模图片处理。
- **CDN 优化**：一些内容分发网络（CDN）如 Cloudflare、AWS CloudFront 也提供自动图像优化功能，根据用户设备自动压缩并提供最佳格式。

6.**响应式图片**

​	为不同设备提供不同大小的图片可以避免不必要的加载。根据设备的屏幕大小和分辨率自动选择合适的图片大小

```
<picture>
  <source srcset="image-800.webp" type="image/webp">
  <source srcset="image-800.jpg" type="image/jpeg">
  <img src="image-400.jpg" alt="Responsive Image" width="400">
</picture>
```



#### 3.CDN

需要频繁加载、影响用户体验的图像都适合使用 CDN 托管

1. **选择合适的 CDN 提供商**
- **评估性能和覆盖范围**：选择一个具有全球覆盖且响应速度快的 CDN 提供商，例如 Cloudflare、Amazon CloudFront、Akamai、Fastly 等。
- **比较价格和服务**：根据你的需求比较不同提供商的定价、服务和功能。

2. **将静态资源托管到 CDN**
- **上传静态内容**：将 CSS、JavaScript、图像、字体和其他静态文件上传到 CDN。
- **更新资源链接**：在 HTML 中将静态资源的链接更改为 CDN 地址。
    ```html
    <link rel="stylesheet" href="https://cdn.example.com/styles.css">
    <script src="https://cdn.example.com/script.js"></script>
    <img src="https://cdn.example.com/images/logo.png" alt="Logo">
    ```

3. **配置缓存策略**
- **设置缓存时间**：为静态资源配置合理的缓存时间，以减少重复请求。
  
    ```nginx
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff|woff2|ttf|svg)$ {
        expires 30d;  # 设置缓存时间为30天
        add_header Cache-Control "public, max-age=2592000";  # 2592000秒=30天
    }
    ```
- **使用版本控制**：在文件名中添加版本号（如 `style.v1.css`），在文件更新时更改版本号，以确保浏览器获取最新资源。

4. **图像优化**
- **使用现代图像格式**：将图像转换为 WebP 格式，提供更高的压缩率和更好的图像质量。
- **启用图像懒加载**：在用户滚动到可见区域时再加载图像，以减少初始加载的资源。
    ```html
    <img src="image.jpg" loading="lazy" alt="Description">
    ```

5. **启用 HTTP/2**
- **使用 HTTP/2 协议**：确保 CDN 支持 HTTP/2，这种协议可以有效地减少请求延迟和提高页面加载速度。
- **使用推送功能**：利用 HTTP/2 的推送功能，提前加载用户将要请求的资源。

6. **使用内容分块加载**
- **按需加载 JavaScript 和 CSS**：确保仅加载用户需要的资源，通过异步或延迟加载技术提高初始加载速度。
    ```html
    <script src="script.js" async></script>
    <link rel="stylesheet" href="styles.css" media="print" onload="this.media='all'">
    ```

7. **DNS 预解析**
- **使用 DNS 预解析**：为 CDN 设置 DNS 预解析，减少资源加载时的 DNS 查找时间。
    ```html
    <link rel="dns-prefetch" href="//cdn.example.com">
    ```

8. **监控和分析**
- **使用监控工具**：使用分析工具监控 CDN 性能，评估资源加载时间和流量使用情况。
- **根据数据优化**：根据访问模式和性能数据动态调整 CDN 配置和资源加载策略。

9. **安全性设置**
- **使用 HTTPS 加密**：确保通过 CDN 提供的内容都使用 HTTPS 加密，提高安全性。
- **DDoS 防护**：选择具备 DDoS 防护功能的 CDN 提供商，以防止恶意攻击。

10. **处理 CORS（跨域资源共享）**
- **配置 CORS 策略**：如果你的 CDN 资源需要在不同域名下访问，确保正确配置 CORS 以允许跨域请求。
    ```nginx
    location / {
        add_header 'Access-Control-Allow-Origin' '*';
    }
    ```

总结
通过实施这些方法，你可以有效地利用 CDN 优化网站的加载速度和性能。每个网站的需求不同，建议根据实际情况进行相应的调整和优化。使用性能测试工具（如 Google PageSpeed Insights、GTmetrix）来评估优化效果，并根据反馈继续进行改进。

#### 4.分块加载

#### 5.图片格式转换  ：将 PNG/JPG 转换为 WebP 格式

​	（**核心图片转换为 WebP**：将网站中占用流量大、访问频繁的图片（如首页大图、banner、产品照片）转换为 WebP 格式。

**保留回退格式**：为了兼容不支持 WebP 的浏览器，可以保留一份原有格式（如 JPEG、PNG）的图片作为回退。

**自动化工具**：通过工具和构建流程（如 Webpack、Vite、Gulp）自动化处理图片转换，确保新的图片也能自动转换为 WebP 格式，并支持不同格式的回退机制。）

### 9.windows本地部署nginx,本地部署前端应用

参考： https://www.cnblogs.com/stones-3/p/15663842.html

下载nginx: http://nginx.org/en/download.html ，解压到自定义目录下即可

修改下`conf/nginx.conf` 文件

```nginx
  location / {
      root   html; #服务默认启动目录
      index  stones/index.html; #默认访问文件 (这里路径需要修改)
  }

```

在html下新建文件夹命名为自己的项目stones

将打包的目录复制到html/stones下并解压

启动nginx服务

浏览器以服务器加端口形式访问`server_name` + `listen` = localhost:80



#### windows上常用的nginx命令
在系统环境变量path中添加nginx安装路径：
使用win+R打开cmd命令行：

查看Nginx的版本号：nginx -V
启动Nginx：start nginx   或者  nginx  ，在nginx目录下logs文件夹会生成pid文件
快速停止或关闭Nginx：nginx -s stop ，在nginx目录下logs文件夹会删除pid文件
正常停止或关闭Nginx：nginx -s quit
配置文件修改重装载命令：nginx -s reload
查看windows任务管理器下Nginx的进程命令：tasklist /fi "imagename eq nginx.exe"
终止单个进程 taskkill /F /pid 252288
检测nginx配置  nginx -t


- 使用 start nginx后，产生了pid,可以正常访问nginx, 再使用nginx -s stop后，pid文件被删除，但还可以正常访问nginx为什么？
可能原因：
1. Nginx 未完全停止
`tasklist | findstr nginx` 如果有输出（仍然存在 nginx.exe 进程），说明 Nginx 还在运行
2. 多个 Nginx 实例在运行
可能 多次启动过 Nginx，导致有多个 nginx.exe 进程在运行。`nginx -s stop` 可能 仅关闭了一个实例，但其他实例仍然在运行。
```shell
# 使用 taskkill 强制终止所有 Nginx 进程：
taskkill /F /IM nginx.exe
# 然后检查：确保所有 Nginx 进程被终止
tasklist | findstr nginx


## 再次启动nginx：
start nginx
# 查找正在运行的 Nginx 进程:
    # 精准匹配 nginx.exe 进程（不区分大小写）,只会列出 完全匹配 nginx.exe 的进程
    tasklist /fi "imagename eq nginx.exe"  
    # 模糊匹配 nginx，返回所有包含 nginx 关键字的进程,可能匹配 nginx.exe、nginx-worker.exe 等类似进程
    tasklist | findstr nginx 
# 停止nginx
nginx -s stop
```
3. Nginx 进程未正确响应 stop 命令
在某些情况下，Nginx 进程可能 卡住或未能完全退出，即使 nginx.pid 被删除，它仍然在运行。
```shell
# 手动检查端口 80（或 Nginx 监听的端口）是否仍然被占用：
netstat -ano | findstr :80
# 如果仍然有进程占用 80 端口，使用：终止使用80端口的进程
taskkill /PID <进程ID> /F
# 例如：taskkill /PID 12345 /F
```




### 10.蓝湖切图下载及Tiny压缩图片

![image-20241021135401780](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20241021135401780.png)

总结：
蓝湖下载切图文件大小：webp < jpg < png(高/低/普通,大小一样) < png(不压缩)
tiny工具压缩后切图文件大小：webp < jpg < png(高/低/普通) = png(不压缩)
tiny工具压缩为webp格式后文件大小：全部等于webp格式大小

蓝湖切图下载选择：

PNG特点：无损压缩，支持透明背景，图像质量高，但文件体积大 适用图标、按钮等UI组件，透明图像，避免使用于大尺寸图

JPG特点：有损压缩，文件体积小，不支持透明背景， 适用展示复杂背景图片或背景，不需要透明背景图片

SVG特点：矢量格式，支持无线缩放不失真，文件体积小，支持透明 适用图标插画等矢量图

webp特点：支持有损无损压缩，支持透明背景，文件体积小，但部分浏览器不兼容 适用网页快速加载图片，体积小

### 11. windows获取目录结构树：

    cd 到目录
    
    tree /a 获取到文件夹
    
    tree /f 获取到文件


### 12. uniapp项目创建使用vscode编辑器
uniapp只能用于微信小程序，不能用于微信小游戏

方式一：Hbuild X中创建uniapp项目
1. Hbuild X中创建uniapp项目（可以自动生成 UniApp 的项目结构和配置文件）
2. 将项目用VScode打开，在 VS Code 中编写业务代码，UniApp 组件和 API 都可以使用，可以使用 uni API，比如 uni.navigateTo() 或 uni.request()。
3. 在 VS Code 中开发完成代码后，切换到 HBuilderX，打开项目目录，进行编译或发行
4. 在 HBuilderX 中可以实现真机调试/多端编译

注意事项：
HbuildX里的uniapp目录结构和vscode中的uniapp目录结构不一样。
结论：hbuilderX创建的uniapp项目转移到vscode是不能直接启动项目的，并且步骤复杂。结论是要么一开始就在hbuilderX开发，要么就其他的编辑器开发，但最好还是用hbuilderX开发

方式二：VScode创建uniapp项目: 
[参考博客]('https://blog.csdn.net/weixin_73320836/article/details/128930047')
如果是创建vue3.0 + vite + javascript的uni-app项目，直接在浏览器打开 https://github.com/dcloudio/uni-preset-vue 切换到vite分支下载zip后缀的压缩文件，解压到本地就可以了。
如果是创建vue3.0 + vite + typescript的uni-app项目，直接在浏览器打开 https://github.com/dcloudio/uni-preset-vue 切换到vite-ts分支下载zip后缀的压缩文件，解压到本地就可以了。

网页运行：
npm run dev:h5

微信小程序运行：
npm run dev:mp-weixin
此时会生成一个dist文件，打开微信开发者工具，导入文件夹dist/dev/mp-weixin,填写项目名称，appID可以选择填写，默认游客模式，点击确认就可运行。


### 13. vite + vue3 + phaser3项目运行到PC和微信小游戏
使用phaser的vite模板

运行微信小游戏：
1. 修改vite.config.js
```js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
    plugins: [vue()],
    build: {
      outDir: 'dist',            // 输出目录
      assetsDir: 'assets',        // 静态资源目录
      rollupOptions: {
          output: {
              entryFileNames: 'game.js',  // 主文件名
              format: 'cjs',              // 微信小游戏不支持 ES 模块
          },
      },
      assetsInlineLimit: 0
    },
});

```


2. 打包：npm run build 

### 14. vite项目打包后asset静态资源里图片变少了（Vite使用的坑）
项目中的图片在打包后发现减少，原因是Vite自动将图片转为了base64格式。解决方案是在vite.config.ts中设置build.assetsInlineLimit为1KB，阻止小文件转base64。
```js
export default ({ mode } : ConfigEnv) : UserConfig => {
  ...
    resolve : {
      alias : [
        {
          find : '@',
          replacement : resolve(__dirname, '../src'),
        },
      ],
      extensions : ['.ts', '.js'],
    },
    ...
    plugins : [
      ...
    ],
    // 增加新的配置
    build:{
      assetsInlineLimit: 0
    }
  }
```

### 15.组件外使用pinia
```js
// 正常是useStore() 是需要传入 pinia 实例的，但是在 setup() 中已经自动注入了 pinia 实例，所以即使你不传入任何参数也能正常使用，但是在组件外属于非 setup()，这时就需要老老实实的按规矩调用人家的 API 了
// 在组件外使用pinia
import pinia from '@/store/index.js'
import useHomeStore from '@/store/homeStore/useHomeStore.js'

const homeStore = useHomeStore(pinia);
console.log('111--', homeStore.width);
```


### 16.linux服务器上nginx部署前端项目：
vite项目中，vite.config.js文件：
```js
// vite.config.js

export default defineConfig({
  base: process.env.NODE_ENV === 'production' ? '/smallPressBig/' : '/',

  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  server: {
    port: 8080,
    open: true,
    cors: true,
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:8080/',
        changeOrigin: true,
        rewrite: path => path.replace(/^\/api/, '')
      }
    }
  },
  build: {
    assetsInlineLimit: 0
  }
})

```

1. 配置项publicPath 或base 在 前端项目的作用：
```js
// publicPath: process.env.NODE_ENV === 'production' ? '/smallPressBig' : ''
base: process.env.NODE_ENV === 'production' ? '/smallPressBig' : ''
```
publicPath 是 Webpack 的配置项，而在 Vite 中它相当于 base，用于指定静态资源的基础路径。它决定了打包后的 HTML 文件如何引用生成的静态资源（如 JS、CSS 文件等）。
在 Vite 项目中，base 通常用来设置打包时的资源路径。如果你在 vite.config.js 中直接配置了类似的 publicPath 或 base，是为了适配部署环境的路径需求。
2. 是否有必要配置base？
这取决于项目的部署方式：
部署在非根路径时是必要的：如果你将项目部署在 https://cheersjoy.cn/smallPressBig/，则需要设置 base 为 /smallPressBig，否则生成的静态资源路径会错误地指向根目录，导致 404 错误。
部署在根路径时不需要：如果项目直接部署在 https://cheersjoy.cn/ 的根目录，则不需要设置 base，静态资源默认从根目录加载。
3. 设置nginx.conf文件
```nginx
server {
		# listen 8080;
		# server_name localhost;

		# 根路径直接指向 cheersjoy 项目,这个有问题
		location / {
			root /var/www/html/cheersjoy;
			index index.html;
			try_files $uri $uri/ /index.html;  # 支持 SPA
		}

		# boom_star 项目路径
		location /boom_star {
			alias /var/www/html/boom_star;
			index index.html;
		}

		# smallPressBig 项目路径
		location /smallPressBig {
			alias /var/www/html/smallPressBig;
			index index.html;
			try_files $uri /index.html;
		}
	}
```
4. 可以通过https://cheersjoy.cn/smallPressBig 访问smallPressBig项目，但https://cheersjoy.cn/ 访问cheersjoy项目暂时有问题，将cheersjoy项目内容直接放到html下可解决问题（可能还有别的方法也可以解决）


### dat.GUI库
参考文档：https://www.cnblogs.com/wuqun/p/14366057.html
dat.GUI 是一个轻量级的图形用户界面库（GUI 组件），使用这个库可以很容易地创建出能够改变代码变量的界面组件。
GitHub 主页：https://github.com/dataarts/dat.gui

使用步骤：
（1）首先在页面的 <head> 标签中添加这个库。
<script type="text/javascript" src="../libs/dat.gui.js"></script>
或者npm i dat.gui
（2）定义一个 JavaScript 对象（这里假设叫做 controls），该对象将保存希望通过 dat.GUI 改变的属性。
var controls = new function () {
    this.rotationSpeed = 0.02;
    //......
};
（3）接下来需要将这个 JavaScript 对象传递给 dat.gui 对象，并设置各个属性的取值范围。
import * as dat from 'dat.gui';

var gui = new dat.GUI();
gui.add(controls, 'rotationSpeed', 0, 0.5);
//......
（4）最后当用户对 dat.GUI 控件进行操作时，controls 里的属性值也会同步修改。我们在程序中直接引用这个属性值就好了。



## Git
### 1.主仓库建立子仓库和主仓库下新建文件夹管理项目有什么区别?
|特性	|主仓库子仓库(Git Submodules)	|主仓库文件夹管理|
|-|-|-|
|独立版本控制|	支持独立提交和版本管理	|所有模块共享一个提交历史|
|操作简便性|	需要额外的子模块命令和设置	|操作简单，直接管理|
|权限控制灵活性	|可以为每个子仓库设置不同权限	|所有文件夹共享主仓库权限|
|适合的团队/项目	|大型项目、多团队、独立发布	|小型项目、协作密集、统一发布|


#### 主仓库建立子仓库:
在主仓库中建立子仓库可以通过 Git 子模块（Submodules） 来实现。子模块是一种将一个 Git 仓库嵌入到另一个 Git 仓库中的方法，便于在主仓库中管理多个独立的项目。
操作步骤：
1. 在主仓库中添加子仓库
进入本地主仓库所在的文件夹，使用 git submodule add 命令将子仓库添加到主仓库中，指定子仓库的 URL 以及本地存放路径，一般放在主仓库目录下。
```bash
git submodule add <子仓库远程地址> <本地路径>
# <子仓库远程地址>：子仓库的 Git 远程地址。
# <本地路径>：子仓库的存放路径（会在主仓库下新建子仓库文件夹）。
```

如果新建远程仓库，还未提交过，就通过上面命令添加到主仓库，则会在本地主仓库目录下新建<本地路径>文件夹，但没有被添加进主仓库下的.gitmodules文件。
需要远程子仓库提交一次，然后本地cd 进入<本地路径>文件夹，通过`git pull`拉取远程子仓库的提交，再执行
```bash
git submodule add <子仓库远程地址> <本地路径>
```
将该子仓库关联到主仓库。
2. 主仓库提交
子模块被添加后，Git 会在主仓库的 .gitmodules 文件中记录子模块的信息。
提交这些变更：
```bash
# 提交单个子模块pc_game
git add .gitmodules pc_game
git commit -m "Add pc_game as a submodule"
# 或者
# git add .
# git commit -m "新增多个子仓库"
```
3. 推送主仓库的变更到远程仓库：
```bash
git push origin master
```


#### 克隆远程主仓库（已包含子模块）：
1. 如果其他开发者从头开始克隆主仓库，初始克隆时还需要同步子模块：
克隆主仓库：
```bash
git clone <主仓库的远程地址>
```
初始化并更新子模块，这会下载并初始化主仓库中的所有子模块：
```bash
cd cj_game
git submodule update --init --recursive
```
2. 其他人在拉取主仓库之后，进入子模块的目录进行代码修改和提交。子模块中的修改直接影响子模块的远程仓库，而无需单独再拉取子仓库。


#### 子模块更新后，主仓库需手动更新子仓库并提交推送远程
1. 拉取远程子仓库更新到本地
```bash
# 更新单个子模块pc_game
cd pc_game
git pull origin master
```
如果希望在主仓库的根目录更新所有子模块，使用以下命令：
```bash
git submodule update --remote --merge
```
2. 主仓库提交并推送远程
子模块更新后，返回到主仓库目录并提交，主仓库就会指向子模块的最新版本：
```bash
git add pc_game 
# 或者
# git add .
git commit -m "Update pc_game submodule"
git push origin master
```

#### 主仓库切换子模块的版本（即子仓库的提交记录）
1. 进入子模块目录: 切换到想要的版本，可以是特定的分支、标签、或提交 SHA 值
```bash
# 1.切换到特定分支：
git checkout branch_name

# 2.切换到特定标签：
git checkout tag_name

# 3.切换到特定提交：
git checkout commit_sha
```
2. 进入主仓库目录
```bash
cd ../..  # 回到主仓库根目录
git add pc_game
git commit -m "Update submodule to new version"
git push origin main  # 推送到主仓库远程分支
```
3. 其他人拉取并同步更新子模块
```bash
git submodule update --init --recursive
```

### 2.本地仓库关联远程仓库
1. 前提：远程新建仓库
进入本地项目文件夹,右键git bash here, 
初始化本地仓库
```bash
git init
```
2. 关联远程仓库： 使用 git remote add 命令来关联远程仓库。通常命名为 origin，也可以使用其他名字
```bash
git remote add origin <远程仓库的URL>
```
3. 验证远程仓库的连接（可选）： 你可以使用以下命令查看远程仓库是否添加成功：
```bash
git remote -v
```
4. 提交并推送代码： 如果本地有未提交的代码，可以先提交再推送到远程仓库：
```bash
git add .
git commit -m "初次提交"
git push -u origin main  # 第一次推送且指定分支为main
```

### 3.更新本地仓库关联的远程仓库URL
step 1: 查看远程仓库地址URL
git remote -v 

step 2: 替换远程仓库URL
git remote set-url origin 新的仓库URL

step 3: 检查更新后查看远程仓库地址URL
git remote -v 

### 4.主仓库下多个子仓库，更新远程URL
子仓库：
进入子仓库文件夹，使用上面方法更新子仓库URL


主仓库：
step 1: 手动更新 .gitmodules 文件中的 URL
打开.gitmodules文件手动修改URL保存

step 2: 同步主仓库中的子模块配置 (.gitmodules 文件)
git submodule sync

step 3：更新子模块的内容（确保子模块使用新 URL 拉取最新的内容：）
git submodule update --recursive --remote

### 5. git pull --rebase 不会创建额外的合并提交，而是让你的本地修改“重新排列”在远程的最新提交之后，从而保持更整洁的 Git 历史

`git pull --rebase origin branch_name`

- 使用场景:
✅ 避免合并提交：如果你想保持一条干净的 Git 历史，避免 merge 产生的多余合并提交，git pull --rebase 是更好的选择。
✅ 多人协作：当你和团队成员都在同一个分支上开发，使用 --rebase 可以减少合并冲突的复杂性。

- 常见问题:
```sh 
# 1.遇到冲突怎么办？ 如果 rebase 过程中出现冲突，Git 会提示你手动解决：
git status

# 2.解决冲突后，使用：
git rebase --continue

# 3.或者，如果你想取消 rebase，可以运行：
git rebase --abort

# 4.如何让 Git 默认使用 rebase？ 你可以设置 Git 拉取时默认使用 rebase：
git config --global pull.rebase true
# 这样，以后 git pull 就会默认使用 rebase 方式。
```





### Git报错： Failed to connect to github.com port 443 解决方案
配置http代理: 配置http代理Windows、Linux、Mac OS 中 git 命令相同：
```bash
git config --global http.proxy 127.0.0.1:7890
git config --global https.proxy 127.0.0.1:7890
```
取消代理命令：
```bash
git config --global --unset http.proxy
git config --global --unset https.proxy
```

注意：
命令中的主机号（127.0.0.1）是使用的代理的主机号(自己电脑有vpn那么本机可看做访问github的代理主机)，即填入127.0.0.1即可，否则填入代理主机 ip(就是网上找的那个ip)
命令中的端口号（7890）为代理软件(7890是clash for window的端口)(代理软件不显示端口的话，就去Windows中的代理服务器设置中查看)或代理主机的监听IP，可以从代理服务器配置中获得，否则填入网上找的那个端口port 
————————————————                    
原文链接：https://blog.csdn.net/zpf1813763637/article/details/128340109


## linux命令
```shell

cd html/
# 将assets移动到cheersjoy202502111834下（文件夹后面加/，明确告诉mv是目录）；如果cheersjoy202502111834不存在，就会将assets重命名为cheersjoy202502111834
mv ./assets ./cheersjoy202502111834/
# 将assets下全部内容移动到cheersjoy202502111834下
mv ./assets/* ./cheersjoy202502111834/

# 创建目录
mkdir [选项] 目录名
# 创建 /path/to/dir 目录，-p：创建父目录。如果上级目录不存在，会一并创建
mkdir -p /path/to/dir

# 创建空文件，如果文件已存在，则更新文件的访问和修改时间
touch [选项] 文件名
# 常用选项：
# -c：如果文件不存在，则不创建新文件。
# -t：设置文件的时间戳： touch -t 202302121200 myfile.txt

```




## deepseek本地部署：
下载ollama：Ollama 是一个开源工具，旨在简化在本地计算机上运行和操作大型语言模型（LLMs）的过程。它专注于让用户能够轻松部署、管理和实验各种开源的LLM（如Meta的Llama系列、Mistral、Gemma等），而无需依赖云端服务或复杂的配置。使得用户能够灵活地管理和使用不同的语言模型

配置系统环境变量：
变量名：OLLAMA_MODELS
变量值：D盘新建的文件夹model存放下载模型

cmd+R打开命令行：
```bash
# 查看ollama版本
ollama -v

# 查看安装了哪些模型
ollama  list 

# 启动模型
ollama run [模型]

# 停止模型
ollama stop

# 查看帮助
/?
```

deepseek-V3是无深度思考模型
deepseek-R1是深度思考模型
DeepSeek-R1 在后训练阶段大规模使用了强化学习技术，在仅有极少标注数据的情况下，极大提升了模型推理能力。在数学、代码、自然语言推理等任务上，性能比肩 OpenAI o1 正式版。
deepseek-V3基于改进的Transformer架构，引入动态注意力机制（Dynamic Attention Mechanism），通过实时调整注意力权重优化文本生成质量。其混合专家（MoE）架构包含6710亿总参数，但每个Token仅激活370亿参数，显著降低计算成本。该模型在内容创作、客服对话等场景中表现出色，训练成本仅为同类闭源模型的1/20。
总结：
  当不启用“深度思考”时，我们使用的是V3模型，它就像一个多面手，能够高效地处理各种语言任务，比如快速生成文章、翻译、聊天等，适合那些需要快速得到答案或者处理多种任务的场景。

  而当我们启用“深度思考”时，就切换到了R1模型，它更像是一个逻辑专家，擅长解决复杂的逻辑问题、进行深度推理，比如数学建模、编程代码生成等。
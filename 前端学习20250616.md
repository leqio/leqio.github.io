# three.js

# canvas

# 图形学

# webGIS

# webGL

# node.js
node.js是javascripte的执行环境，可以让js在电脑直接执行，不限于浏览器
安装nvm及node

查看安装是否完成命令：node --version 或node -v

在node里面，要使用ESModule,要把js文件改为.mjs后缀，或者在package.json里面加入type等于module

早期版本的node只支持Commonjs,在新版的node中也支持了ESmodule。
举例：
- node使用ESmodule，
方法1：将js后缀改为mjs, 终端执行指令 node index.mjs
```js
/**test.mjs文件*/
export const x = 'hello';

/**index.mjs文件*/
import {x} from './test.mjs'
console.log(x); // hello
```
方法2：需要在package.json文件中加入 "type": "module",  指定为ESmodules,终端执行指令 node index.js
```js
/**test.js文件*/
export const x = 'hello';

/**index.js文件*/
import {x} from './test.mjs'
console.log(x); // hello

```

- node使用Commonjs，node index.js
```js
/**test.js文件*/
// module.exports = 'hello';
module.exports.y = 'hello';

/**index.js文件*/
const x = require('./test.js');
// console.log(x); // hello
console.log(module.exports); // {y: 'hello'}， module.exports是一个对象{}
console.log(x.y); // hello
```
 
## node内建模组
### os模组（operating system作业系统）
```js
const os = require('os'); // os模组是node内建模组，不需要写详细路径，os模组会存放与此电脑相关的信息
console.log(os.arch());// os.arch()返回电脑系统类型：x64
console.log(os.cpus());// os.cpus()返回电脑cpu处理器信息
```

### fs模组（file system档案系统）
fs的每一种操作，都有三种不同的语法：
1.回调函数
2.同步函数
3.promise

```js
const fs = require('fs'); // fs模组，操作电脑档案系统，例如读取档案，创建档案，删除档案等

// .writeFile()创建档案，接收三个参数：[档案路径],[档案内容],[回调函数]，回调函数会在创建档案后执行
// fs.writeFile('./test.txt','hello',function (err) {
//     console.log(err);
// });

// .readFile()读取档案，接收三个参数：[档案路径],[档案类型],[回调函数]，回调函数会在读取档案后执行
// fs.readFile('./test.txt','utf-8',function (err, data) {
//     console.log(err);
//     console.log(data); // data为读取到的内容
// });

// .unlink()删除档案，接收两个参数：[档案路径],[回调函数]，回调函数会在删除档案后执行
fs.unlink('./test.txt', function (err) {
    console.log(err);
});

// 复制档案
// 重命名档案
// ...



```

#### fs模块路径动态拼接： [档案路径]默认拼接node命令所在目录，当使用./或../拼接路径容易出现错误，解决方案：
在使用fs模块操作文件时，使用完整路径,比如：'C:\\Users\\29732\\Desktop\\20230306\\Nodejs20250616\\test.txt' 
还有一种方法：
1.在CommonJS中，内置变量__dirname,表示当前文件所在的目录，使用 __dirname + '/test.txt'
2.在ES中，无内置变量__dirname，则使用：
```js
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// 在 ES 模块中，import.meta.url 是一个内置的属性，它返回当前模块文件的完整 URL（以 file: 协议开头）
const __fileName = fileURLToPath(import.meta.url);  // fileURLToPath：将 import.meta.url 返回的 URL 转换为本地文件路径。
const __dirname = dirname(__fileName);  // dirname：从文件路径中提取目录路径。
console.log(__dirname);  // 输出当前文件所在的目录路径
```

fs模块路径动态拼接:
```js
fs.readFile('C:\\Users\\29732\\Desktop\\20230306\\Nodejs20250616\\test.txt','utf-8',function (err, data) {
    console.log(err);
    console.log(data); // data为读取到的内容
});
fs.readFile(__dirname + '/test.txt','utf-8',function (err, data) {
    console.log(err);
    console.log(data); // data为读取到的内容
});
```

### http模组，创建http的伺服器
nodejs可以写后端程序代码，也就是创建一个伺服器。而http模组就是用来创建伺服器的模组。

通过http模块提供的http.createServer()方法，就
能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。

服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如：IIS、Apache等。通过安装这些服务器软件，
就能把一台普通的电脑变成一台web服务器。
在Node.js中，我们不需要使用IS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的
http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。

IP地址:通常用“点分十进制”表示成(a.b.c.d)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如：用点分十进表示的1P地址(192.168.1.1)
注意：互联网中每台Web服务器，都有自己的IP地址，例如：大家可以在Windows的终端中运行ping www.baidu..com命令，即可查看到百度服务器的IP地址(分为IPv4和IPv6)。
 
IPv4：32 位（4 字节），通常表示为 4 组十进制数，每组 8 位，用点（.）分隔。例如：192.168.1.1。
IPv6：128 位（16 字节），通常表示为 8 组十六进制数，每组 16 位，用冒号（:）分隔。例如：240e:ff:e020:99b:0:ff:b099:cff1。

IPv6 取代 IPv4 的原因：IPv6 的引入主要是为了解决 IPv4 地址耗尽的问题，并提供更好的安全性、路由效率和自动配置能力。
尽管 IPv6 有许多优势，但由于 IPv4 的存量过大且两者协议不兼容，IPv6 无法在短期内完全取代 IPv4。目前，IPv4 和 IPv6 会共存一段时间，通过双栈协议、隧道技术和协议转换技术等手段进行过渡。


#### http用法：
例子1：
```js
/** 创建一个伺服器，监听3000端口，当有网络请求进来时执行回调函数（将数据返回到客户端） 
*/
//1.导入http模组
const http = require('http');

// 2.创建web服务器
// .createServer(),创建伺服器，参数：接收一个回调函数作为参数，该回调函数会在接收网络请求时执行，回调函数有两个参数：request，response; 返回值：返回一个server对象
const server = http.createServer(function (req, res) {
    // res.write('<h1>hello world</h1>'); // 回应资料到客户端, 浏览器会自己根据回应内容判断内容类型，这里浏览器会根据<h1>标签判断为html内容
    // res.end();  // 结束回应

    // 浏览器会自己根据回应内容判断内容类型，上面浏览器会根据<h1>标签判断为html内容；
    // 实际上，不能让浏览器自己判断内容，可能产生安全问题或乱码，我们可以通过.setHeader()设置response的Header。
    /* 
    解释：
    header是response的一个要素，用来给浏览器提供额外的资讯，浏览器根据heade的资讯进行不同的操作。
    例如：Content-Type代表回应内容的类型;
    Content-length代表回应内容的长度；
    Server: 服务器种类
    ...

    */
    
    // res.setHeader()接收两个参数，[键名key]，[键值value]
    // res.setHeader('Content-Type', 'text/html; charset=utf-8');// 'Content-Type'代表内容的种类，'text/html'代表内容的种类的值是html
    res.setHeader('Content-Type', 'text/plain');// 'Content-Type'代表内容的种类，'text/plain'代表内容的种类的值是纯文字
    res.write('<h1>hello world</h1>'); // 回应资料到客户端，内容类型是根据上面Content-Type规定的
    res.end();  // 结束回应


    /* 
    延展：
    res.write('<h1>hello world</h1>');中<h1>hello world</h1>可以替换为整个html内容，可以通过fs.readFile()读取html文件内容，
    为了使网页内容多元化，可以连接数据库，
    可以加入前端框架react或vue,使网页更动态，
    可以在node前面加入nginx,使服务器能承受更大流量，也更安全。
    */
});
server.listen(3000);// 监听3000端口

/* 
启动该伺服器：
第一步：终端输入执行：node index.js  
第二步：浏览器打开页面 localhost:3000，会显示hello world
*/

/* 
解释：
http是一种网路传输协议，是整个网路运行基础，基本上他占据了95%的所有网路流量。
http的运作方式：客户端（浏览器）发送request请求到伺服器端（服务器），伺服器接收请求后，会将response回应传给客户端
localhost（IP：127.0.0.1）代表本地电脑，3000是端口，端口是电脑与外界交流的出口，我们需要把服务器架设在某一个端口上，客户端需要指定端口才可以访问服务器。

浏览器默认使用80或者443的端口，他们分别代表http以及http，如果没有输入端口的话，浏览器默认使用这两个端口。

当文件index.js修改后，需要重启服务器，客户端才能更新请求内容。
重启服务器：终端按下ctrl+C，再次输入node index.js ,按下enter键。
每次更新程序都要重启服务器太麻烦，node有个第三方插件nodemon,可以监听特定文件，只要该文件内容发生改变，node就会重启对应服务器
*/
```

例子2：
```js
//1.导入http模组
const http = require('http'); // 导入http模组

// 2.创建web服务器实例
    /* 
    // 写法1，代码清晰：
    const server = http.createServer();
    server.on('request', (req, res) => {
        console.log('有请求进入服务器...');
    });

    // 写法2，适合简单逻辑：
    const server = http.createServer((req, res) => {
        console.log('有请求进入服务器...');
    });
    // .createServer()参数是一个callback，回调函数callback有两个参数，resquest,response,回调函数会在有网络请求进来时执行
    */
const server = http.createServer();
// 3.为服务器实例绑定request事件，监听客户端请求
server.on('request', (req, res) => {
    console.log('有请求进入服务器...');
     

    //req是请求对像，它包含与客户端相关的数据和属性，例如：
    //req.url是客户端请球的URL地址
    //req.method是客户端的method请求类型
    console.log('req:',req.url, req.method);  // 客户端请求进来后，这段在服务器上输出

    // res是返回客户端对象
    // res.setHeader()，手动设置编码格式，规定浏览器以什么格式解析返回给客户端的数据
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    //res.end()方法的作用：向客户端发送指定的内容，并结束这次情求的处理过程
    res.end('hello world'); // 在客户端显示，可以是文字，可以是html,可以是其他

});
// 4.监听服务器端口
const port = 3000;
const ip = '127.0.0.1';
// .listen(), 监听ip端口,有三个参数：[port],[ip],[callback], 回调函数callback会在服务器开始监听请求的时候被调用
server.listen(port,ip, () => {
    console.log(`sever is running at http://${ip}:${port}`);
});

```


#### http根据不同的url响应不同的html内容:
```js
import http from 'http'

const port = 3000;
const ip = '127.0.0.1';

const server = http.createServer();
server.on('request', (req, res) => {
     const url = req.url;                    //1.获取请求的url地址
     console.log('req.url:',url);
     let content = '<h1>404 Not found!</h1>' //2.设置默认的内容

     if(url === '/' || url === '/index.html'){
        content = '<h1>首页</h1>';           //3.用户请求的是首页
     } else if (url === '/about.html') {
        content = '<h1>关于页面</h1>';       //4.用户请求的是关于页面
     };

     res.setHeader('Content-Type','text/html; charset=utf-8');//5.设置Content-Type响应头，防止中文乱码
     res.end(content);                       //6.把内容发给客户端

});

// .listen(), 监听ip端口,有三个参数：[port],[ip],[callback], 回调函数callback会在服务器开始监听请求的时候被调用
server.listen(port,ip, () => {
    console.log(`sever is running at http://${ip}:${port}`);
});


```

优化客户端请求路径:
```js
//1. 导入模块
import http from 'http';
import fs from 'fs';
import path, {dirname} from 'path';
import { fileURLToPath } from 'url';

const ip = '127.0.0.1';
const port = '3000';

const __fileNmae = fileURLToPath(import.meta.url);
const __dirName = dirname(__fileNmae); // 获取当前文件目录

// 2.1创建web服务器
const server = http.createServer();
// 2.2监听web服务器的request事件
server.on('request', (req, res) => {
    // 3.1获取客户端请求的url地址
    const url = req.url; 
    // 当客户端请求的url是 /clock/index.html

    // 3.2将获取到的url映射为本地文件路径
    // const fpath = path.join(__dirName, url);

    /* 优化请求路径，比如直接请求 /index.html，而不是 /clock/index.html */
    // 5.1 预定义空白文件存放路径
    let fpath = '';
    if(url === '/') {
        // 5.2若请求路径为 / , 则手动指定文件的存放路径
        fpath = path.join(__dirName, './clock/index.html'); // 当客户端请求的url是 /
    } else {
        // 5.3 若请求路径不为 / ,则动态拼接文件的存放路径!!!
        fpath = path.join(__dirName, './clock', url);  // 当客户端请求的url是 /index.html
    }

    // 4.1读取文件内容
    fs.readFile(fpath, 'utf-8', (err, dataStr) => {
        if(err) return res.end('404 not found');
        res.end(dataStr);
    });
});
// 2.3启动web服务器
server.listen(port, ip, () => {
    console.log(`sever is running at http://${ip}:${port}`);
});
```

### path模组，用于处理路径的模块
path.join(),将多个路径片段拼接为完整路径
path.baseName()，从路径字符串中将文件名解析出来
path.extname(),获取路径中文件扩展名
```js
import path from 'path'

// path.join(),参数为路径片段字符串
const pathStr = path.join(...['/a','/b/c','../','./d','e']);
console.log(pathStr); // \a\b\d\e
console.log(...['/a','/b/c','../','./d','e']); // ...[]作用展开数组
// fs中使用路径拼接，可以不用 + 拼接路径，可以使用path.join()方法拼接路径


// path.basename(path[,ext]), path必选表示路径字符串，ext可选，表示扩展名，返回值：路径中的最后一部分
const fpath = '/a/b/c/d.html';
const fullname = path.basename(fpath); // 返回完整文件名
console.log(fullname); // d.html

const nameWithoutExt = path.basename(fpath,'.html');  // 返回无后缀文件名
console.log(nameWithoutExt); // d


// path.extname(),获取路径中文件扩展名
const fExt = path.extname(fpath);
console.log(fExt); // .html
```


### node内置模组使用案例
#### 案例1：使用fs模组，将原生html内容拆分为css/js/html文件
步骤：
1.创建两个正则表达式，分别匹配<style>和<script>
2.使用fs模块，读取需要被处理的html文件
3.自定义resolveCSS方法，来写入index.css样式文件
4.自定义resolveJS方法，来写入index.js脚本文件
5.自定义resolveHTML方法，来写入index.html文件


注意：fs.writeFile(),只能创建文件，不可以创建路径。
```js
/**
 * 读取并将01.html中的css/script/html标签分离为各自的文件.css/.js/.html
 * （1）读取01.html内容，
 * （2）定义匹配css/script的正则，获取css/script的内容，将获取的内容写入对应的文件.css/.js
 * （3）将01.html中关于css/script替换为文件引用，并将替换后的html写入对应的文件.html
 */

import fs from 'fs';
import path, { dirname, resolve } from 'path';
import { fileURLToPath } from 'url';

const __fileName = fileURLToPath(import.meta.url); // 从URL解析出文件路径
const __dirName = dirname(__fileName); // 获取文件所在目录路径

// 1.3 定义匹配<style></style>标签正则，/s空白字符，/S非空白字符，*匹配任意次
const regStyle = /<style>[\s\S]*<\/style>/
// 1.4 定义匹配<script></script>标签正则，/s空白字符，/S非空白字符，*匹配任意次
const regScript = /<script>[\s\S]*<\/script>/


// 2.1 读取文件
fs.readFile(path.join(__dirName, './01.html'), 'utf8', (err,data) => {
    if(err) {
        console.log('读取文件失败' + err.message);
    };
    // 将读取的文件内容拆分并分别写入clock文件夹（手动创建clock文件夹）中，自动新建文件保存为css,js,html文件
    resolveCSS(data);
    resolveScript(data);
    resolveHTML(data);
})


/**
 * 定义处理css方法
 * @param {*} htmlStr 
 */
function resolveCSS(htmlStr) {
    // .exec(),执行正则并返回结果数组
    const r1 = regStyle.exec(htmlStr);
    const newCSS = r1[0].replace('<style>', '').replace('</style>','');  // 去掉<style></style>标签
    fs.writeFile(path.join(__dirName, './clock/index.css'), newCSS, (err) => {
        if(err) return  console.log('写入css失败' + err.message);
        console.log('写入css成功');
    })
}

/**
 * 定义处理js方法
 * @param {*} htmlStr 
 */
function resolveScript(htmlStr) {
    // .exec(),执行正则并返回结果数组
    const r2 = regScript.exec(htmlStr);
    const newJS = r2[0].replace('<script>', '').replace('</script>','');  // 去掉<script></script>标签
    fs.writeFile(path.join(__dirName, './clock/index.js'), newJS, (err) => {
        if(err) return  console.log('写入js失败' + err.message);
        console.log('写入js成功');
    })
}

/**
 * 定义处理html方法
 * @param {*} htmlStr 
 */
function resolveHTML(htmlStr) {
    
    /* 
    .replace(searchValue, replaceValue)，
    searchValue：可以是一个字符串，表示要查找的内容，也可以是一个正则表达式，用于更复杂的匹配。
    replaceValue：可以是一个字符串，表示替换后的内容，也可以是一个函数，用于动态生成替换内容。
    返回值：返回一个新的字符串，其中匹配的部分被替换为新的内容，不改变原字符串。
    */
    const newHTML = htmlStr
        .replace(regStyle, '<link rel="stylesheet" href="./index.css" />')
        .replace(regScript, '<script src="./index.js"></script>'); 
    fs.writeFile(path.join(__dirName, './clock/index.html'), newHTML, (err) => {
        if(err) return  console.log('写入html失败' + err.message);
        console.log('写入html文件成功');
    })
}
```

## node的模块作用域
每一个js都是一个自定义模块
每一个js都有一个module对象，存储了当前模块有关信息
使用module.exports对象将模块内的对象共享出去，使用require()方法导入外界共享进来的对象；
在es中，使用export代替module.exports，import...from...代替require()


## npm (node包管理器)
检查npm版本号：npm -v

要使用npm安装包，需要有文件package.json,
可以在文件夹直接创建文件package.json，
但最好使用指令创建：npm init, 不用输入值一直按enter键。它可以初始化nodejs的项目，也就是产生文件package.json。

如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中。
与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中。

安装到devDependencies节点中：
npm i 包名 -D 或者 npm install 包名 --save-dev

安装到dependencies节点中：
npm i 包名


* 安装lodash(一个工具集): npm i lodash
文件夹内会出现：
node_modules: node模块，里面存放项目安装的插件
package-lock.json：锁定项目使用插件的版本号，确保重新安装插件时，不会有不相容的情况发生。
package.json：中，dependencies（依赖）记录项目里的插件，
可以通过指令：npm install 或者npm i ，会根据package.json的dependencies内容重新安装项目使用的插件。
移除插件：npm uninstall lodash
使用loadsh,在程序代码文件中使用:
```js
const _ = require('lodash');
const x = _.shuffle([1,2,3,4,5,6]); // .shuffle()随机打乱数组,返回随机打乱后的新数组
console.log(x); 
const y = _.isEmpty([1,2,3,4,5]); // .isEmpty()判断数组是否为空，返回true/false
console.log(y); 
```

* 安装nodemon（监控文件并自动执行文件）插件,要使用全域安装-g：npm i -g nodemon,
linux和mac系统报错的话，需要使用sudo npm i -g nodemon, sudo是superuser do(超级管理员执行)
当插件安装到全域nodemodules时，插件路径会被添加到PATH的环境变量里面。

使用nodemon: nodemon属于CLI（Command-Line Interface命令行交互）插件，在终端里使用指令：nodemon index.js 
nodemon就会实时监控index.js内容并执行index.js。 

CLI：全称Command-Line Interface，命令行交互。

* package.json中scripts的值是自定义CLI指令
```json
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "nodeStart": "node index.js",
    "nodemonStart": "nodemon index.js"
},
```
上面"nodeStart": "node index.js"是我们自定义的指令，左边的是指令名，可以随意取名，
要执行scripts里的指令：npm run [指令名]，
比如 npm run nodeStart

因此，利用npm和package.json中scripts，可以自定义cli指令。


nodemon 注意：
nodemon全局安装（npm i -g nodemon）时：可以在终端直接执行nodemon index.js
nodemon局部安装（npm i nodemon）时：不可以在终端直接执行nodemon index.js会报错，但可以通过scripts里自定义cli指令执行：npm run nodemonStart
这是因为npm在执行scripts的指令时，会先查看局部插件里是否存在该插件，如果有则先使用局部插件执行指令。





## express--专门创建web服务器的
学习目标：
能够使用express.static0快速托管静态资源
能够使用express路由精简项目结构
能够使用常见的express中间件
能够使用express创建API接口
能够在express中启用cors跨域资源共享


### 初识Express
Express是基于内置的http模块进一步封装出来的，能够极大的提高开发效率。

安装：
npm i express


1. express监听GET请求：
通过app.get()方法，可以监听客户端的GET请求，具体的语法格式如下：
```js
// 参数1：客户端请求的UL地址
// 参数2：请求对应的处理函数
// req:请求对象（包含了与请求相关的属性与方法）
// res:响应对象（包含了与响应相关的属性与方法）
app.get('请求URL',function(req,res) {
    /*处理函数*/
})
```


2. express监听POST请求：
通过app.post()方法，可以监听客户端的POST请求，具体的语法格式如下：
```js
// 参数1：客户端请求的UL地址
// 参数2：请求对应的处理函数
// req:请求对象（包含了与请求相关的属性与方法）
// res:响应对象（包含了与响应相关的属性与方法）
app.post('请求URL',function(req,res) {
    /*处理函数*/
})
```

3. 通过res.send()方法，将处理好的内容发送给客户端
```js
app.get('/user', (req, res) => {
    res.send(
        {
            name: 'lihu',
            age: 20,
            gender: 1
        }
    )
});


app.post('/user', (req, res) => {
    res.send('请求成功');
})
```


4. req.query 获取客户端请求的查询字符串参数
5. req.params 获取url中的动态参数


例子：
```js
// 1.导入express
import express from 'express';

// 2.创建web服务器
const app = express();

// 4.监听客户端的GET和POST请求，并向客户端响应具体的内容
app.get('/user', (req, res) => {
    res.send( { name: 'lihu', age: 20, gender: 1});
});
app.post('/user', (req, res) => {
    res.send('请求成功');
})

// 5.req.query 获取客户端请求的查询字符串参数
app.get('/', (req, res) => {
    // req.query默认是空对象
    // 客户端使用?name=zs$age=20 这种查询字符串形式，发送到服务器的参数，可以通过req.query对象访问到
    // req.query.name  req.query.age
    console.log(req.query);
})

// 6.req.params 获取url中的动态参数
app.get('/user/:id/:name', (req, res) => {
    // req.params 默认是空对象
    // 存放着通过 : 动态匹配到的参数值
    res.send(req.params);
    console.log(req.params.id);
    console.log(req.params.name);
})

// 3.启动web服务器
app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
})
```


#### 托管静态资源
1. express.static(), 创建静态资源服务器，可以将public目录下的图片，css, js文件对外开放访问。
`app.use(express.static('public'));`
比如访问：
http:localhost:3000/images/bg.jpg
http:localhost:3000/css/style.css

2. 要设置多个静态资源目录时，多次调用就行：
```js
app.use(express.static('public'));
app.use(express.static('fileImg'));
```

注意：
Express在指定的静态目录中查找文件，并对外提供资源的访问路径。
因此，存放静态文件的目录名不会出现在URL中。

3. 希望在托管的静态资源访问路径之前，挂载路径前缀：
`app.use('/public', express.static('public'))`
比如访问：
http:localhost:3000/public/images/bg.jpg
http:localhost:3000/public/css/style.css

### Express路由

```js
// 文件：router/user.js
// 1.导入express
import express from 'express'

/* 
不建议路由挂载到app上：
const app = express();
app.get('/', () ={}); // 这种url请求是一条路由
*/

// 2.创建路由对象
const router = express.Router();

// 3.挂载具体路由
router.get('/user/list', (req, res) => {
    res.send('get user list.')
});
router.post('/user/add', (req, res) => {
    res.send('add new user.')
});

// 4.导出路由
export default router;

// ----------------------------------
// 5. 在其他文件中导入路由
import useRouter from './router/user.js'
const app = express();
app.use(useRouter); // 将路由模块注册到app中

// 当需要客户端访问每一个路由前都要加个某前缀，比如'/api/user/list',这么写：
// app.use('/api',useRouter); 

app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
})

```

app.use()的作用：注册全局中间件

### Express中间件
客户端发起请求---》服务器接收请求---》中间件1---》中间件2---》...---》中间件N---》服务器处理完毕，响应请求给客户端

中间件本质是一个函数
```js
import express from 'express';

const app = express();

// (req,res,next) => {next();}，这是中间件函数，包含三个参数：req,res,next
// 注意：中间件函数的形参列表中，必须包含next参数，而路由处理函数只包含req和res。
app.get('/user/list', (req,res,next) => {
    // next函数的作用：实现多个中间件连续调用的关键，表示把流转关系转交给下一个中间件或路由
    next(); 
})
```

1. 定义一个最简单的中间件函数：
```js
// 定义一个最简单的中间件函数：
const mw = function(req,res,next) {
    console.log('这是一个简单的中间件函数');

    // 注意：在当前中间件的业务处理完后，必须调用next()函数，表示把流转关系交给下一个中间件或路由
    next();
};
```

2. 全局生效的中间件
客户端发起的任何请求到达服务器后，都会触发的中间件，叫全局生效的中间件。
通过调用app.use(中间件函数)，即可定义一个全局生效中间件。
```js
import express from 'express';

const app = express();

// 定义一个最简单的中间件函数：
const mw = function(req,res,next) {
    console.log('这是一个简单的中间件函数');

    // 注意：在当前中间件的业务处理完后，必须调用next()函数，表示把流转关系交给下一个中间件或路由
    next();
};

app.use(mw); // mw中间件全局生效
```

3. 中间件和路由执行顺序
```js
import express from 'express';

const app = express();
// 注册全局生效中间件函数：
app.use((req,res,next) => {
    console.log('调用第一个全局中间件');
    next(); 
});
app.use((req,res,next) => {
    console.log('调用第二个全局中间件');
    next(); 
});
app.use((req,res,next) => {
    console.log('调用第三个全局中间件');
    next(); 
});
// 请求这个路由，会依次触发上述三个中间件
app.get('/user', (req,res) => {
    res.send('User Page');
});

app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});
```

4. 局部生效的中间件
局部生效的中间件的定义和使用：
```js

import express from 'express';

const app = express();
// 注册全局生效中间件函数：
const mw1 = (req,res,next) => {
    console.log('调用全局中间件mw1');
    next(); 
}
app.use(mw1);

const mw2 = (req,res,next) => {
    console.log('调用局部中间件mw2');
    next(); 
}

// 使用局部中间件
// 局部中间件mw2,只在当前路由中才生效
// 请求这个路由,会依次触发全局中间件mw1, 局部中间件mw2,
app.get('/user', mw2, (req,res) => {
    res.send('User Page');
});

// 局部中间件mw2,在这个路由中不生效
app.get('/about', (req,res) => {
    res.send('User Page');
});
```

5. 定义多个局部中间件
```js
const mw2 = (req,res,next) => {
    console.log('调用局部中间件mw2');
    next(); 
}
const mw3 = (req,res,next) => {
    console.log('调用局部中间件mw3');
    next(); 
}

// 使用多个局部中间件
// 写法一：
app.get('/user', mw2, mw3, (req,res) => {
    res.send('User Page');
});
app.get('/user', [mw2, mw3], (req,res) => {
    res.send('User Page');
});
```


6. 使用中间件的注意事项
（1）一定要在 路由之前 注册中间件；
（2）客户端发送过来的请求，可以连续调用多个中间件进行处理；
（3）执行完中间件的业务代码之后，不要忘记调用 next() 函数；
（4）为了防止代码逻辑混乱，调用 next() 函数后不要再写 额外的代码；
（5）连续调用多个中间件时，多个中间件之间，共享req和res对象。

#### 中间件的分类
1. 应用级别的中间件，挂载到app实例上的中间件：
```js
// 应用级别app.use()全局中间件， 
app.use((req,res,next) => {
    console.log('调用全局中间件mw1');
    next(); 
});

// 应用级别app.post()/get()局部中间件
app.get('/user', (req,res,next) => {
    console.log('调用全局中间件mw1');
    next(); 
    }, 
    (req,res) => {
        res.send('User Page');
    }
);

```

2. 路由级别的中间件，绑定到router上的中间件
```js
import express from 'express';

const app = express();

const router = express.Router();

const mw2 = (req,res,next) => {
    console.log('调用局部中间件mw2');
    next(); 
}

// 路由级别的中间件
router.get('/user', mw2, (req,res) => {
    res.send('User Page');
});

app.use('/', router)
```


3. 错误级别的中间件
专门用来捕获整个项目中发生的异常错误
格式： 错误级别中间件的函数中，必须有4个形参，顺序是(err, req, res, next)
注意：错误级别中间件一定要放到所有路由后
```js
import express from 'express';

const app = express();

// 1. 路由
app.get('/', (req, res) => {  
    throw new Error('服务器内部发生了错误！');  // 1.1 抛出一个自定义错误
    res.send('Home page');
});

// 2. 错误级别中间件
// 注意：错误级别中间件一定要放到所有路由后
app.use((err, req, res, next) => {  
    console.log('发生错误：' + err.message);  // 2.1 在服务器打印错误消息
    res.send('Error! ' + err.messgae); // 2.2 向客户端响应错误相关内容
});

app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});
```


#### Express内置的中间件
自Express4.16.0版本开始，Express内置了3个常用的中间件，极大的提高了Express项目的开发效率和体验：
（1）express.static快速托管静态资源的内置中间件，例如：HTML文件、图片、CSS样式等（无兼容性）
（2）express.json解析JSON格式的 '请求体数据'（有兼容性，仅在4.16.0+版本中可用）
（3）express.urlencoded解析URL-encoded格式的 '请求体数据'（有兼容性，仅在4.16.0+版本中可用）
```js
// 配置解析 application/json 格式数据的内置中间件
app.use(express.json());
// 配置解析 application/x-www-form-urlencoded 格式数据的内置中间件
app.use(express.urlencoded({extended: false}));
```

使用例子：
```js
import express from 'express';

const app = express();

// 配置解析 application/json 格式数据的内置中间件
// 确保 express.json() 在路由之前被调用
app.use(express.json());

app.post('/user', (req, res) => {  
    // 在服务器，req.body可以获取客户端发送过来请求的请求体数据
    // 如果不配置解析数据中间件，req.body则显示为 undefined
    console.log(req.body);  // { name: 'zs', age: 20 }

    res.send('ok');
});

/* 
// 注意：错误级别中间件一定要放到所有路由后
app.use((err, req, res, next) => {  // 2. 错误级别中间件
    console.log('发生错误：' + err.message);  // 2.1 在服务器打印错误消息
    res.send('Error! ' + err.messgae); // 2.2 向客户端响应错误相关内容
});
*/

app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});

// 使用postman模拟客户端请求：127.0.0.1/user ,在body里选择json格式，输入{ "name": 'zs', "age": 20 },发起请求
```


#### 第三方中间件
使用第三方中间件提高开发效率
例如：在express@4.16.0之前的版本，经常使用body-parser这个第三方中间件来解析请求体数据
使用步骤：
（1）运行 npm install body-parser 安装中间件
（2）使用 import 导入中间件
（3）调用 app.use() 注册并使用中间件
注意：Express内置的express.urlencoded中间件，就是基于body-parser这个第三方中间件进一步封装出来的。

使用例子：
```js
import express from 'express';
import parser from 'body-parser' // 导入第三方中间件

const app = express();

// 配置解析 表单数据 格式的第三方中间件
app.use(parser.urlencoded({ extended: false}));

app.post('/book', (req, res) => {  
    // 在服务器，req.body可以获取客户端发送过来请求的请求体数据
    // 如果不配置解析数据中间件，req.body则显示为undefined
    console.log(req.body);  // { bookname: '西游记', author: '吴承恩' }

    res.send('ok');
});

/* // 注意：错误级别中间件一定要放到所有路由后
app.use((err, req, res, next) => {  // 2. 错误级别中间件
    console.log('发生错误：' + err.message);  // 2.1 在服务器打印错误消息
    res.send('Error! ' + err.messgae); // 2.2 向客户端响应错误相关内容
}); */

app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});

// 使用postman模拟客户端请求：127.0.0.1/book ,在body里选择x-www-form-urlencoded格式，
// 表格输入 bookname / 西游记 ,author / 吴承恩
// 发起请求

```


#### 自定义中间件
自己手动模拟一个类似于express.unlencoded 这样的中间件，来解析POST提交到服务器的表单数据
实现步骤：
（1）定义中间件
（2）监听req的data事件
（3）监听req的end事件
（4）使用querystring模块解析请求体数据
（5）将解析出来的数据对象挂载为req.body
（6）将自定义中间件封装为模块

前五步使用例子：
```js
import express from 'express'
// querystring是node内置的模块，用来处理查询字符串，这个模块的parse()函数可以吧查询字符串解析成对象格式
import qs from 'querystring' 

const app = express();

// 自定义中间件，并挂载到app上
app.use((req, res, next) => {
    // 1.定义变量用来存储客户端发送的请求体数据
    let str = ''; 

    // 2.监听req的data事件
    /* 注意：
        在中间件中，需要监听req对象的data事件，来获取客户端发送到服务器的数据。
    如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以dta事件可能会触
    发多次，每一次触发data事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。
    */
   req.on('data', (chunk) => {
        // 2.1 拼接请求体数据
        str += chunk;
   });

   // 3.监听req的end事件（请求体发送完毕后自动触发）
   req.on('end', () => {
        // 3.1 打印完整的请求体数据
        console.log('str--',str);
        // 3.2 将字符串格式的请求体数据，解析为对象格式
        const body = qs.parse(str);
        console.log('body--', body);
    
        // 3.3.将body挂载到 req 上，方便后续其他中间件使用
        req.body = body;

        // 3.4.执行next函数，流程流转到下一步
        next();
   })
});

app.post('/user', (req, res) => {
    res.send(req.body);
});
app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});
```

第六步将自定义中间件封装为模块：
```js
/* bodyParser.js 文件
自定义中间件bodyParser模块化：
*/
// querystring是node内置的模块，用来处理查询字符串，这个模块的parse()函数可以吧查询字符串解析成对象格式
import qs from 'querystring' ;

const bodyParser = (req, res, next) => {
    // 1.定义变量用来存储客户端发送的请求体数据
    let str = ''; 

    // 2.监听req的data事件
    req.on('data', (chunk) => {
            // 2.1 拼接请求体数据
            str += chunk;
    });

    // 3.监听req的end事件（请求体发送完毕后自动触发）
    req.on('end', () => {
            // 3.1 打印完整的请求体数据
            console.log('str--',str);
            // 3.2 将字符串格式的请求体数据，解析为对象格式
            const body = qs.parse(str);
            console.log('body--', body);

            // 3.3.将body挂载到 req 上，方便后续其他中间件使用
            req.body = body;

            // 3.4.执行next函数，流程流转到下一步
            next();
    });

};

export default bodyParser;

/* --------------------------- */
// 在其他文件中使用封装的bodyParser
import express from 'express'
import bodyParser from './bodyParser.js'; // 导入自定义中间件模块

const app = express();

// 将自定义中间件bodyParser，挂载到app上
app.use(bodyParser);

app.post('/user', (req, res) => {
    res.send(req.body);
});
app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});


```



### 使用Express写接口

#### 编写get请求接口
1. 创建路由
```js
// 001编写get请求接口路由.js

import express from 'express'

const router = express.Router();

// 挂载对应路由
router.get('/user', (req, res) => {
    // 通过req.query获取客户端通过查询字符串，发送到服务器的数据
    const query = req.query;
    // 调用res.send()方法，向客户端响应处理结果
    res.send({
        status: 0, // 0表示成功，1表示失败
        msg: 'GET请求成功！', // 状态描述
        data: query, // 需要响应给客户端的数据
    })
});

export default router;
```

2. 路由挂载到服务器实例app上
```js
import express from 'express'
import router from './001编写get请求接口路由.js';

const app = express();

// 注册路由到app上
app.use('/api', router); // 在所有url请求前加个 /api 前缀
// 启动服务器
app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});


// 通过客户端发起get请求：127.0.0.1/api/user?id=1 ，服务器会返回给客户端数据：
// {
//     "status": 0,
//     "msg": "GET请求成功！",
//     "data": {
//         "id": "1"
//     }
// }
```

#### 编写post请求接口
1. 创建路由
```js
// 002编写post请求接口路由.js
import express from 'express'

const router = express.Router();

// 挂载对应路由
router.post('/user', (req, res) => {
    // 通过req.body获取客户端通过请求体，发送到服务器的数据
    const body = req.body;
    // 调用res.send()方法，向客户端响应处理结果
    res.send({
        status: 0, // 0表示成功，1表示失败
        msg: 'GET请求成功！', // 状态描述
        data: body, // 需要响应给客户端的数据
    })
});

export default router;
```

2. 路由挂载到服务器实例app上
!! 注意：如果要获取URL-encoded格式的请求体body 数据，必须配置中间件`app.use(express.urlencoded({extended:false)`
```js
import express from 'express'
// import router from './001编写get请求接口路由.js';
import router from './002编写post请求接口路由.js';

const app = express();

// !! 注意：如果要获取URL-encoded格式的请求体body 数据，必须配置中间件app.use(express.urlencoded({extended:false)
app.use(express.urlencoded({extended: false}));

// 注册路由到app上
app.use('/api', router); // 在所有url请求前加个 /api 前缀
// 启动服务器
app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});


// 通过客户端发起post请求：127.0.0.1/api/user ,请求体为x-www-form-urlencoded形式，数据为 name / zhangsan，服务器会返回给客户端数据：
// {
//     "status": 0,
//     "msg": "GET请求成功！",
//     "data": {
//         "name": "zhangsan"
//     }
// }
```


#### CORS 跨域资源共享(主流的解决方案，推荐使用)
1. 接口的跨域问题
刚才编写的GET和POST接口，存在一个很严重的问题，不支持跨域请求。
解决接口跨域问题的方案主要有两种：
- CORS(主流的解决方案，推荐使用)
- JSONP(有缺陷的解决方案：只支持GET请求)

2. 接口服务器 使用 CORS中间件 解决跨域问题
cors是Express的一个第三方中间件。通过安装和配置cors中间件，可以很方便地解决跨域问题。

使用步骤分为如下3步：
(1)运行 `npm install cors` 安装中间件
(2)使用 `import cors from 'cors'` 导入中间件
(3)在路由之前调用`app.use(cors())`配置中间件
使用例子：
```js
import express from 'express'
// import router from './001编写get请求接口路由.js';
import router from './002编写post请求接口路由.js';
import cors from 'cors'

const app = express();

// !! 注意：如果要获取URL-encoded格式的请求体body 数据，必须配置中间件app.use(express.urlencoded({extended:false)
app.use(express.urlencoded({extended: false}));


// !! 注意：一定要在路由之前使用 CORS 解决跨域问题
app.use(cors());

// 注册路由到app上
app.use('/api', router); // 在所有url请求前加个 /api 前缀
// 启动服务器
app.listen(80, () => {
    console.log('express sever running at 127.0.0.1');
});


// 通过客户端发起post请求：127.0.0.1/api/user ,请求体为x-www-form-urlencoded形式，数据为 name / zhangsan，服务器会返回给客户端数据：
// {
//     "status": 0,
//     "msg": "GET请求成功！",
//     "data": {
//         "name": "zhangsan"
//     }
// }
```

3. 关于 CORS：
CORS(Cross-Origin Resource Sharing,跨域资源共享)由一系列HTTP响应头组成，这些HTTP响应头决定
浏览器是否阻止前端JS代码跨域获取资源。
浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果 接口服务器 配置了CORS相关的HTTP响应头，
就可以解除浏览器端的跨域访问限制。

CORS的注意事项：
（1）CORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了CORS的接口。
（2）CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level22的浏览器，才能正常访问开启了CORS的服
务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。

4. CORS 响应头部 -- Access-Control-Allow-Origin
响应头部中可以携带一个 Access-Control-Allow-Origin 字段，语法：
`Access-Control-Allow-Origin: <origin> | *`
其中，origin参数的值指定了允许访问该资源的外域URL。
例如，下面字段值只允许来自 http://itmm.cn 的请求：
`res.setHeader('Access-Control-Allow-Origin', 'http://itmm.cn')`
如果，设置字段值为通配符 * ,则允许来自任何域的请求：
`res.setHeader('Access-Control-Allow-Origin', '*')`

5. CORS 响应头部 -- Access-Control-Allow-Headers
默认情况下，CORS 仅支持客户端向服务器发送如下的 9个 请求头：
Accept,
Accept-Language,
Content-Language,
DPR,
Downlink,
Save-Data,
Viewport-Width,
Width,
Content-Type(在Cors中值仅限于 text/plain、multipart/form-data、application/x-www-form-urlcoded 三者之一)

注解：
- text/plain：纯文本格式。用于发送简单的文本数据，例如日志信息、纯文本内容等。
```js
app.post('/text', (req, res) => {
    let data = '';
    req.on('data', chunk => {
        data += chunk.toString();
    });
    // 请求体发送完毕后自动触发req的end事件
    req.on('end', () => {
        console.log('接收到的文本:', data);
        res.send('文本已接收');
    });
});
```
- multipart/form-data：多部分表单数据。用于 上传文件 和 复杂表单数据。
    特点：请求体被分割成多个部分（parts），每个部分可以包含不同类型的数据（例如文本字段和文件）。
    每个部分都有自己的 Content-Type 和 Content-Disposition，用于描述该部分的内容。
    通常用于文件上传和包含文件的表单提交。
通常需要使用第三方库中间件（如 multer）来处理文件上传：
```js
const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

app.post('/upload', upload.single('file'), (req, res) => {
    console.log('接收到的文件:', req.file);
    console.log('接收到的表单数据:', req.body);
    res.send('文件已上传');
});
```
- application/x-www-form-urlencoded：URL 编码的表单数据。用于提交简单的表单数据。
    特点：请求体是键值对形式的字符串，键和值都经过 URL 编码。
    格式为 `key1=value1&key2=value2`。
    通常用于简单的表单提交，不支持文件上传。
使用 express.urlencoded() 中间件：
```js
app.use(express.urlencoded({ extended: true }));

app.post('/form', (req, res) => {
    console.log('接收到的表单数据:', req.body);
    res.send('表单数据已接收');
});
```

如果客户端向服务器发送了除上面9个以外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败。
```js
// 允许客户端向服务器发送额外的 Content-Type 请求头和 X-Costom-Header 请求头
// 多个请求头之间用 , 隔开
res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-Costom-Header');
```

6. CORS 响应头部 -- Access-Control-Allow-Methods
默认情况下，CORS仅支持客户端发起GET、POST、HEAD请求。
如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control--Alow-Methods来指明实际请求所允许使用的HTTP方法。
```js
//只允许POST、GET、DELETE、HEAD清求方法
res.setHeader('Access-Control-Allow-Methods', 'POST, GET, DELETE, HEAD')
//允许所有的HTTP请求方法
res.setHeader('Access-Control-Allow-Methods', '*')
```

7. CORS的请求分类
客户端在请求CORS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是：简单请求、预检请求。

- 简单请求：
同时满足以下两大条件的请求，就属于简单请求：
（1）请求方式：GET、POST、HEAD三者之一
（2）HTTP头部信息不超过以下几种字段：
无自定义头部字段、
Accept、
Accept--Language、
Content-Language、
DPR、
Downlink、
Save-Data、
Viewport-.Width、
Width、
Content-Type(在Cors中只有三个值application/x-www-form-urlencoded,multipart/form-data,text/plain)

- 预检请求（OPTION请求）：
只要符合以下任何一个条件的请求，都需要进行预检请求：
（1）请求方式为GET、POST、HEAD之外的请求Method类型
（2）请求头中包含自定义头部字段
（3）向服务器发送了 application/json 格式的数据
在浏览器与服务器正式通信之前，浏览器会先发送 OPTION请求 进行预检，以获知服务器是否允许该实际请求，所以这一
次的OPTION请求称为“预检请求”。
服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。


简单请求的特点：客户端与服务器之间只会发生一次请求。
预检请求的特点：客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求。

#### JSONP 跨域资源共享(有缺陷的解决方案：只支持GET请求)
1. JSONP概念：浏览器端通过<script></script>标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据
的方式叫做JSONP。
特点：
①JSONP不属于真正的Ajax请求，因为它没有使用XMLHttpRequest这个对象。
②JSONP仅支持GET请求，不支持POST、PUT、DELETE等请求。

2. 创建JSONP接口的注意事项
如果项目中已经配置了CORS跨域资源共享，为了防止冲突，必须在配置 CORS中间件 之前声明JSONP的接口。否则JSONP接口会被处理成开启了CORS的接口。
示例代码如下：
```js
// 必须优先创建 JSONP 接口，（这个接口不会被处理成CORS接口）
app.get('/api/jsonp', (req, res) => {});

// 再配置CORS中间件（后续所有接口都会被处理成CORS接口）
app.use(cors());
// 这是一个开启了CORS的接口
app.get('/api/user', (req, res) => {})
```

3. 实现JSONP接口的步骤
（1）获取客户端发送过来的回调函数的名字
（2）得到要通过JSONP形式发送给客户端的数据
（3）根据前两步得到的数据，拼接出一个函数调用的字符串
（4）把上一步拼接得到的字符串，响应给客户端的<script></script>标签进行解析执行

```js
app.get('/api/jsonp', (req, res) => {
    // 1.获取客户端发送过来的回调函数的名字
    const funcName = req.query.callback();
    // 2.得到要通过JSONP形式发送给客户端的数据
    const data = {name: 'zs', age: 22};
    // 3.根据前两步得到的数据，拼接出一个函数调用的字符串
    const scriptStr = `${funcName}(${JSONP.stringify(data)})`;
    // 4.把上一步拼接得到的字符串，响应给客户端的<script></script>标签进行解析执行
    res.send(scriptStr);
});
```




### 数据库
#### 数据库的基本概念
#### 安装并配置MySQL
没有本地安装mysql，使用远程免费mysql数据库sqlPub
数据库名称：testnode
数据库用户：testnode
数据库密码：5LNwsAfxDy0NZZoW
数据库地址端口：mysql2.sqlpub.com:3307
注册邮箱：lle837334@gmail.com

#### MySQL的基本使用
#### 在Express中操作MySQL
步骤：
（1）安装操作mysql数据库的第三方模块（mysql）
（2）通过mysql模块连接到mysql数据库
（3）通过mysql模块执行sql语句


具体如下：
（1）mysql模块是托管于npm上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力
想要在项目中使用它，需要先运行如下命令，将mysql安装为项目的依赖包：`npm i mysql`
（2）配置mysql模块
在使用mysql模块操作mysql数据库之前，必须先对mysql模块进行必要的配置，主要配置步骤如下
```js
// 1.导入mysql模块
import mysql from 'mysql'

// 2.建立与mysql数据库的连接
const db = mysql.createPool({
    host: '127.0.0.1', // 数据库ip地址
    user: 'root', //登录数据库的账号
    password: 'admin123', //登录数据库的密码
    database: 'my_db_01', // 指定操作哪个数据库
})
```
（3）测试mysql模块能否正常工作
调用 db.query() 函数，指定要执行的sql语句，通过回调函数拿到执行的结果：
```js
// 检测mysql模块能否正常工作
db.query('SELECT 1', (err, results) => {
    // mysql模块工作期间出错了
    if(err) return console.log(err.message);
    
    // 只要能打印出 [ RowDataPacket {'1': 1} ]的结果，就证明数据库连接正常
    console.log(results);
});
```
（4）查询 users表中的数据
```js
const sqlStr = 'select * from users';
db.query(sqlStr, (err, results) => {
    if(err) return console.log(err.message); // 查询失败

// 注意：如果执行的是select查询语句，则执行的结果是数组
    console.log(results); // 查询成功
})
```
（5）向users表中插入数据
```js
// 1.要插入到users表中的数据对象
const user = {username: 'zhangsan', password: '123'};
// 2.待执行的sql语句，其中英文 ? 表示占位符
const sqlStr = 'INSERT INTO users (username, password) VALUES (?, ?)';
// 3.使用数组形式，依次为 ? 占位符指定具体的值
db.query(sqlStr, [user.username, user.password], (err, results) => {
    if(err) return console.log(err.message); // 失败

    if(results.affectedRows === 1) {
        console.log('插入数据成功！');
    }
})
```
（6）插入数据的便捷方式：如果向表中新增数据时，数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：
```js
// 1.要插入到users表中的数据对象
const user = {username: 'zhangsan', password: '123'};
// 2.待执行的sql语句，其中英文 ? 表示占位符
const sqlStr = 'INSERT INTO users SET ?';
// 3.直接将数据对象当做占位符的值
db.query(sqlStr, user, (err, results) => {
    if(err) return console.log(err.message); // 失败

    if(results.affectedRows === 1) {
        console.log('插入数据成功！');
    }
})
```
（7）批量插入数据
```js
// 要插入的数据对象
const user = [
    { username: 'zhangsan', password: '123' },
    { username: 'lisi', password: '456' },
    { username: 'wangwu', password: '789' }
];
// 1. 待执行的 SQL 语句，使用 VALUES (...) 的批量插入语法
const sqlStr = 'INSERT INTO users (username, password) VALUES ?';

// 2. 将 user 数组转换为适合批量插入的格式
const values = user.map(item => [item.username, item.password]);
// values 是 [['zhangsan','123'], ['lisi','456'], ['wangwu','789']]

// 3. 执行批量插入
// 第二个参数必须写为[values]
db.query(sqlStr, [values], (err, results) => {
    if (err) return console.log('插入数据失败：' + err.message);

    if (results.affectedRows === user.length) {
        console.log('批量插入数据成功，共插入了 ' + results.affectedRows + ' 条数据');
    } else {
        console.log('插入数据失败');
    }
});

```

（8）更新users表中数据
```js
// 1.要更新的数据对象
const user = {id: 7, username: 'aaa', password: '000'};
// 2.要执行的sql语句
const sqlStr = 'update users set username = ? , password = ? where id = ?';
// 3.调用db.query() 执行sql语句的同时，使用数组依次为占位符指定具体的值
db.query(sqlStr, [user.username, user.password, user.id], (err, results) => {
    if (err) return console.log('更新数据失败：' + err.message);

    if (results.affectedRows === 1) {
        console.log('更新数据成功');
    }
});
```
（9）更新数据的便捷方式：如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速更新表数据。
```js
// 1.要更新的数据对象
const user = {id: 7, username: 'aaa', password: '000'};
// 2.要执行的sql语句
const sqlStr = 'update users set ? where id = ?';
// 3.调用db.query() 执行sql语句的同时，使用数组依次为占位符指定具体的值
db.query(sqlStr, [user, user.id], (err, results) => {
    if (err) return console.log('更新数据失败：' + err.message);

    if (results.affectedRows === 1) {
        console.log('更新数据成功');
    }
});
```
（10）删除数据
```js
// 1.要执行的sql语句
const sqlStr = 'delete from users where id = ?';
// 3.调用db.query() 执行sql语句的同时，为占位符指定具体的值
// 注意：如果sql语句中有多个占位符，则必须使用数组为每个占位符指定具体的值
// 如果sql语句中只有一个占位符，则可以省略数组
// 下面是删除id为7的数据
db.query(sqlStr, 7, (err, results) => {
    if (err) return console.log('删除数据失败：' + err.message);

    if (results.affectedRows === 1) {
        console.log('删除数据成功');
    }
});
```
（11）标记删除：使用删除数据时，为数据保险起见，不做数据删除，而是将数据标记删除,使用update代替delete,只更新数据状态，不真正删除数据。
```js
// 1.要执行的sql语句
// 将id为7的数据的status字段更新为1（标识数据删除状态）
db.query('update users set status = 1 where id = ?', 7, (err, results) => {
    if (err) return console.log('更新数据失败：' + err.message);

    if (results.affectedRows === 1) {
        console.log('更新数据成功');
    }
});
```


#### 前后端的身份认证
##### web开发模式：基于服务端渲染的传统Web开发模式、基于前后端分离的新型Web开发模式
目前主流的Web开发模式有两种，分别是：基于服务端渲染的传统Web开发模式、基于前后端分离的新型Web开发模式。

1. 服务端渲染
概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不
需要使用Ajax这样的技术额外请求页面的数据。代码示例如下：
```js
app.get('/index.html', (req, res) => {
    // 1.要渲染的数据
    const user = {name: 'zs', age: 20};
    // 2.服务器端通过字符串的拼接，动态生成html内容
    const html = `<h1>姓名：${user.name}, 年龄：${user.age}</h1>`;
    // 3.把生成好的页面内容响应给客户端，因此，客户端拿到的是带有真实数据的html页面
    res.send(html);
})
```
优点：
（1）前端耗时少。因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。
（2）有利于SEO（Search Engine Optimization，搜索引擎优化）。因为服务器端响应的是完整的HTML页面内容，所以爬虫更容易爬取获得信息，更有利于SEO。
缺点：
（1）占用服务器端资源。即服务器端完成HTML页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。
（2）不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于
项目高效开发。

2. 前后端分离
概念：前后端分离的开发模式，依赖于Ajax技术的广泛应用。简而言之，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式。

优点：
（1）开发体验好。前端专注于U川页面的开发，后端专注于的开发，且前端有更多的选择性。
（2）用户体验好。Ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。
（3）减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。
缺点：
不利于SEO。因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。
（解决方案：利用Vue、React等前端框架的SSR(server side render)技术能够很好的解决SEO问题！）

SSR 是一种在服务器端生成页面内容的技术，而不是在客户端动态生成。
这样，搜索引擎爬虫可以直接抓取到完整的 HTML 内容，从而提高页面的 SEO 效果。
常见的 SSR 框架：
Vue.js：使用 Vue.js 的 SSR 框架（如 Nuxt.js）可以实现服务器端渲染。
React.js：使用 React.js 的 SSR 框架（如 Next.js）可以实现服务器端渲染。
Angular：Angular 也支持 SSR，通过 Angular Universal 可以实现服务器端渲染。

3. 如何选择Web开发模式？
不谈业务场景而盲目选择使用何种开发模式都是耍流氓。
·比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SO，则这时我们就需要使用服务器端渲染：
·而类似后台管理项目，交互性比较强，不需要考虑SEO,那么就可以使用前后端分离的开发模式。
另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了
首屏服务器端渲染+其他页面前后端分离的开发模式。


##### 不同开发模式下的身份认证
身份认证(Authentication)：又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。
例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。

对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：
- 服务端渲染推荐使用 Session 认证机制
- 前后端分离推荐使用 JWT 认证机制

Session认证的局限性：Session认证机制需要配合Cookie才能实现。由于Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。

注意：
当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制。
当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制。

1. Session 认证机制

HTTP协议有个特点：无状态性：指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，也就是服务器不会
主动保留每次HTTP请求的状态。（理解为超市收银员不会记得每位客户是否是超市会员）

如何突破HTTP无状态的限制：使用 Cookie （可以理解为超市会员卡，客户每次来超市给收银员出示会员卡购物）。

Cookie是存储在用户浏览器中的一段不超过4KB的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。
不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器。

Cookie的几大特性：
（1）自动发送
（2）域名独立
（3）过期时限
（4）4KB限制

Cookie在身份认证中的作用：
客户端第一次请求服务器的时候，服务器通过 响应头 的形式，向客户端发送一个身份认证的Cookie,客户端会自动将Cookie保存在浏览器中。
随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie,通过 请求头 的形式发送给
服务器，服务器即可验明客户端的身份，将客户端请求的内容响应给客户端。

Cookie不具有安全性：
由于Cookie是存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全
性。因此不建议服务器将重要的隐私数据，通过Cookie的形式发送给浏览器。

注意：干万不要使用Cookie存储重要且隐私的数据！比如用户的身份信息、密码等。

提高身份认证的安全性：
理解为，为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证。只有收银机确认存在的
会员卡，才能被正常使用。
这种“会员卡+刷卡认证”的设计理念，就是Session认证机制的精髓。

- Session认证机制的工作原理：
（1）浏览器(客户端)登录（提交账号和密码） 给服务器;
（2）服务器验证账号密码，将登录成功的用户信息存储在服务器内存中，同时生成对应的Cookie字符串;
（3）服务器将生成的Cookie响应给客户端;
（4）浏览器(客户端)自动把Cookie存储在当前域名下;
（5）浏览器(客户端)再次发起请求时，通过请求头自动把当前域名下所有可用的Cookie发送给服务器;
（6）服务器根据请求头中携带的Cookie,从内存中查找对应的用户信息;用户的身份认证成功后，服务器针对当前用户生成特定的响应内容;
（7）服务器把针对当前用户生成特定的响应内容响应给浏览器(客户端)。


2. 在express中使用session认证
（1）配置express-session中间件
安装express-session： `npm i express-session`
```js
// 1.导入session中间件
import session from 'express-session'
// 2.注册session中间件
app.use(session({
    secret: 'keyboard cat', // secret属性的值为任意字符串
    resave: false, // 固定写法
    saveUninitialized: true // 固定写法
}))
```
（2）向session中存入数据
当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息：
```js
// 1.导入session中间件
import session from 'express-session'
// 2.注册session中间件
app.use(session({
    secret: 'keyboard cat', // secret属性的值为任意字符串
    resave: false, // 固定写法
    saveUninitialized: true // 固定写法
}));

// 3.客户端提交数据，服务器接收数据，存储到session
app.post('/api/login', (req, res) => {
    // 判断用户提交的登录信息是否正确
    if(req.body.username !== 'admin' || req.body.password !== '000000') {
        return res.send({status: 1, msg: '登录失败'});
    };

    // 注意：只有成功配置了express-session才能通过req点出session属性
    req.session.user = req.body; // 将用户信息，存储到session中
    req.session.isLogin = true; // 将用户的登录状态，存储到session中

    res.send({status: 0, msg: '登录成功'});
});


```
（3）从session取数据,响应给客户端
```js
// 4.从session取数据,响应给客户端
app.get('/api/username', (req, res) => {
    // 判断用户是否登录
    if(!req.session.isLogin) {
        return res.send({status: 1, msg: 'fail'});
    };

    res.send({status: 0, msg: 'success', username: req.session.user.username});
});
```
（4）清空session
调用req.session.destroy()函数，即可清空服务器保存的session信息
```js
// 退出登录的接口
app.post('/api/loginout',(req, res) => {
    // 清空当前客户端对应的session信息
    req.session.destroy();
    res.send({
        status: 0,
        msg: '退出登录成功'
    })
});
```


3. JWT认证机制
Session认证的局限性：Session认证机制需要配合Cookie才能实现。由于Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。

注意：
当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制。
当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制。

JWT(JSON Web Token)是目前最流行的跨域认证解决方案。

- JWT认证机制的工作原理：
（1）浏览器(客户端)登录（提交账号和密码） 给服务器;
（2）服务器验证账号密码，验证通过后，将用户信息对象，经过加密后生成 Token 字符串;
（3）服务器将生成的 Token 响应给客户端;
（4）浏览器(客户端)把 Token 存储到 LocalStorage或SessionStorage中;
（5）浏览器(客户端)再次发起请求时，通过请求头的Authorization字段，将 Token 发送给服务器;
（6）服务器把 Token 字符串还原成用户的信息对象，用户的身份认证成功后，服务器针对当前用户生成特定的响应内容;
（7）服务器把针对当前用户生成特定的响应内容响应给浏览器(客户端)。

总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。

- JWT通常由三部分组成，分别是Header(头部)、Payload(有效荷载)、Signature(签名)。
三者之间使用英文的“.”分隔，格式：`Header.Payload.Signature`

Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。
Header和Signature是安全性相关的部分，只是为了保证Token的安全性。

4. 在express中使用JWT认证
（1）安装两个JWT相关的包：`npm i jsonwebtoken express-jwt`
其中，jsonwebtoken 用于生成JWT字符串，express-jwt用于将JWT字符串解析还原成JSON对象。
（2）导入JWT两个包
```js
// 1.导入jsonwebtoken，用于生成JWT字符串
import jwt from 'jsonwebtoken';
// 2.导入express-jwt，用于将JWT字符串解析还原成JSON对象
import expressJWT from 'express-jwt';
```
（3）定义secret密钥
为保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的secret密钥：
当生成JWT字符串的时候，需要使用secret密钥对用户信息加密，最终得到加密好的JWT字符串；
当爸JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密。
```js
// 3.secret 密钥的本质：就是一个字符串。建议将secret 密钥命名为secretKey。
const secretKey = 'itskkkms NLj we2e';
```
（4）在登陆成功后生成JWT字符串
调用jsonwebtoken包提供的sign()方法，将用户信息加密成JWT字符串，响应给客户端：
!!!注意：千万不要把密码加密到token字符串中
```js
// 1.导入jsonwebtoken，用于生成JWT字符串
import jwt from 'jsonwebtoken';
// 2.导入express-jwt，用于将JWT字符串解析还原成JSON对象
import expressJWT from 'express-jwt';

// 3.secret 密钥的本质：就是一个字符串。建议将secret 密钥命名为secretKey。
const secretKey = 'itskkkms NLj we2e';

// 登录接口
app.post('/api/login', (req, res) => {
    // ...省略登录失败情况下的代码

    // 用户登录成功后，生成JWT字符串，通过token属性响应给客户端
    res.send({
        status: 200,
        message: '登陆成功'，
        // 调用jwt.sign()，生成JWT字符串，三个参数，分别是：
        // 参数1：用户信息对象:
        // 参数2：加密密钥、
        // 参数3：配置对象(可以配置当前token的有效期,30s是30秒，1h是1小时)
        // !!!注意：千万不要把密码加密到token字符串中
        token: jwt.sign( {username: 'userinfo.username'}, secretKey, {expiresIn: '30s'});
    });
});
```
（5）将JWT字符串还原为JSON对象
客户端每次访问有权限的接口时，都要主动通过请求头中的Authorization字段，将Token字符串发到服务器进行身份认证。
此时，服务器可以通过express-jwt这个中间件，自动将客户端发送来的token还原为json对象。
```js
// 1.导入jsonwebtoken，用于生成JWT字符串
import jwt from 'jsonwebtoken';
// 2.导入express-jwt，用于将JWT字符串解析还原成JSON对象
import expressJWT from 'express-jwt';

// 3.secret 密钥的本质：就是一个字符串。建议将secret 密钥命名为secretKey。
const secretKey = 'itskkkms NLj we2e';

// 4. 使用app.use()注册中间件
// express-jwt({secret: secretKey})用来解析token的中间件
// .unless({ path: [/^\/api\//] }) 用来指定哪些接口不需要访问权限
app.use(expressJWT.expressjwt({ secret: secretKey }).unless({ path: [/^\/api\//] }));


// 登录接口
app.post('/api/login', (req, res) => {
    // ...省略登录失败情况下的代码

    // 用户登录成功后，生成JWT字符串，通过token属性响应给客户端
    res.send({
        status: 200,
        message: '登陆成功'，
        // 调用jwt.sign()，生成JWT字符串，三个参数，分别是：
        // 参数1：用户信息对象:
        // 参数2：加密密钥、
        // 参数3：配置对象(可以配置当前token的有效期,30s是30秒，1h是1小时)
        token: jwt.sign( {username: 'userinfo.username'}, secretKey, {expiresIn: '30s'});
    });
});
```
（6）使用req.user获取用户信息
当express-jwt这个中间件配置成功后，即可在有权限的接口中，使用req.user对象，来访问JWT字符串中解析出来的用户信息了
```js
// 例如，这是一个有权限的API接口
app.get('/admin/get/info', (req, res) => {
    console.log(req.user);
    res.send({
        status: 200,
        message: '获取用户信息成功',
        data: req.auth.user,
    })
});

/* 
使用postman模拟有权限的接口请求，
第一步：使用post请求接口/api/login，body中输入用户名密码，发起请求，后返回一个token
第二步：使用get请求接口/admin/get/info，Head中输入字段Authorization，值写为上面的 token，token前一定要加 Bearer ，
比如 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6NTM4MTYsInVzZXJuYW1lIjoibGl1MTIzMTIiLCJuaWNrbmFtZSI6IiIsImVtYWlsIjoiIiwiaWF0IjoxNzUxNDY5NTc0LCJleHAiOjE3NTE1MDU1NzR9.sIduz5v423QYrldd3xn6sqERPBUX164qKlKpevAzozA'
发起请求，后返回用户信息
*/
```
（8）捕获解析JWT失败后产生的错误
当使用express-jwt解析Token字符串时，如果客户端发送来的token过期或不合法，或产生一个解析失败的错误，影响项目正常运行，我们可以通过 express的错误中间件 ，捕获这个错误并进行处理：
```js
// 使用全局错误中间件，捕获捕token解析错误并进行处理
// !!!注意：错误级别中间件一定要放到所有路由后
app.use((err, req, res, next) => {  
    // token解析失败导致的错误
    if(err.name === 'UnauthorizedError') {
        return res.send({
            status: 401,
            message: '无效的token'
        })
    };
    // 其他原因导致的错误
    res.send({
        status: 500,
        message: '未知错误'
    })
})
```

## 项目演练
### 1.项目初始化
1. 新建文件夹aip-sever作为根目录，终端运行`npm init -y`
在package.json中加入 ` "type": "module", `
2. 安装express特定版本v4.17.1， `npm i express@4.17.1`
3. 新建app.js作为整个项目的入口文件,初始化代码：
```js
import express from 'express'

const app = express();

app.listen(3007, () => {
    console.log('express sever running at 127.0.0.1:3007');
})
```
4. 配置cors跨域
（1）安装cors中间件，`npm i cors`
（2）在app.js中导入cors中间件
```js
import cors from 'cors';

app.use(cors());
```
5. 配置解析表单数据 application/x-www-form-urlcoded 的中间件
```js
// 配置解析 application/x-www-form-urlcoded 格式的表单数据中间件
app.use(express.urlencoded({ extended: false }));
```
6. 初始化路由相关文件夹
6.1 根目录新建router文件夹--存放所有 路由 模块：
路由模块中，只存放客户端的请求与处理函数之间的映射关系。
6.2 根目录新建router_handle文件夹--存放所有 路由处理函数 模块
路由处理函数模块中，专门负责存放每个路由对应的处理函数。
7. 初始化路由模块
（1）在router目录新建 user.js文件--用户路由模块
```js
/**
 * 文件: /router/user.js
 * 这里定义用户相关路由
 */
import express from 'express'

const router = express.Router();

// 注册新用户接口
router.post('/reg', (req, res) => {
    res.send('reguser OK');
});

// 用户登录接口
router.post('/login', (req, res) => {
    res.send('login OK');
});

export default router;
```
（2）抽离用户路由模块中处理函数
文件: /router/user.js
```js
/**
 * 文件: /router/user.js
 * 这里定义用户相关路由
 */

import express from 'express'
import userHandle from '../router_handle/user.js';

const router = express.Router();

// 注册新用户接口
router.post('/reg', userHandle.reg);
// 用户登录接口
router.post('/login', userHandle.login);

export default router;

```
文件: /router_handle/user.js
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 注册新用户接口处理函数
const reg = (req, res) => {
    res.send('reguser OK');
};
// 登录接口处理函数
const login =  (req, res) => {
    res.send('login OK');
};

export default {reg, login};
```

### 2. 注册登录
1. navicate连接mysql数据库, 新建ev_users表
2. 在api接口项目中，安装并配置第三方mysql模块，来连接和操作mysql数据库。`npm i mysql`
3. 在项目根目录新建/db/index.js文件，用于存放自定义模块创建数据库的连接对象
```js
/**
 * 文件: /db/index.js
 * 用于存放自定义模块创建数据库的连接对象
 */
import mysql from 'mysql'

const db = mysql.createPool({
    host: 'mysql2.sqlpub.com',
    port: 3307,  // 指定端口号
    user: 'testnode',
    password: '5LNwsAfxDy0NZZoW',
    database: 'testnode'
});

export default db;
```
4. 检测用户名是否被占用
（1）导入数据库
（2）接口处理函数中，使用数据库sql进行数据处理
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'

// 注册新用户接口处理函数
const regUser = (req, res) => {
    // 获取客户端提交到服务器的用户信息
    const userinfo = req.body;
    console.log('userinfo--', userinfo);
    // 对表单中的数据，进行合法性校验
    if (!userinfo.username || !userinfo.password) {
        return res.send({
            status: 1,
            message: '用户名或密码不合法！'
        });
    }

    // 4.2 定义sql语句，查询用户名是否被占用
    const sqlStr = 'SELECT * FROM ev_users WHERE username = ?';
    db.query(sqlStr, userinfo.username, (err, results) => {
        // 执行sql语句失败
        if (err) return res.send({ status: 1, message: err.message });
        // 判断用户名是否被占用
        if (results.length > 0) {
            return res.send({ status: 1, message: '用户名已被占用！请更换用户名！' });
        }

        // 用户名可以使用，继续后续逻辑
        // TODO: 插入新用户到数据库
        const insertSql = 'INSERT INTO ev_users (username, password) VALUES (?, ?)';
        db.query(insertSql, [userinfo.username, userinfo.password], (err, insertResults) => {
            if (err) return res.send({ status: 1, message: err.message });
            if (insertResults.affectedRows !== 1) {
                return res.send({ status: 1, message: '注册失败！' });
            }
            res.send({ status: 0, message: '注册成功！' });
        });
    });
};

// 登录接口处理函数
const login =  (req, res) => {
    res.send('login OK');
};

export default {regUser, login};
```


解决报错：ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 错误通常发生在 MySQL 8.0 及更高版本中，因为 MySQL 8.0 默认使用了新的身份验证插件 caching_sha2_password，而旧版本的 MySQL 客户端库（如 mysql 模块）可能不支持这种新的身份验证方式。
如果你使用的是 mysql 模块，可以升级到支持新身份验证方式的版本：npm install mysql2
```js
/**
 * 文件: /db/index.js
 * 用于存放自定义模块创建数据库的连接对象
 */
import mysql from 'mysql2'

const db = mysql.createPool({
    host: 'mysql2.sqlpub.com',
    port: 3307,  // 指定端口号
    user: 'testnode',
    password: '5LNwsAfxDy0NZZoW',
    database: 'testnode'
});

export default db;
```

5. 数据库密码加密
为了保证密码的安全性，不建议在数据库以明文的形式保存用户密码，推荐对密码进行加密存储。

在当前项目中，使用 bcryptjs 对用户密码进行加密，优点：
·加密之后的密码，无法被逆向破解
·同一明文密码多次加密，得到的加密结果各不相同，保证了安全性
（1）运行如下命令，安装指定版本的bcryptjs: `npm i bcryptjs@2.4.3`
（2）.在/router_hand1er/user.js中，导入bcryptjs:
```js
const bcrypt require('bcryptjs')
```
（3）在注册用户的处理函数中，确认用户名可用之后，调用bcrypt.hashSync(明文密码，随机盐的长度)方法，对用户的密
码进行加密处理
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'
// 5.1 导入 bcryptjs 加密插件
import bcrypt from 'bcryptjs' 

// 注册新用户接口处理函数
const regUser = (req, res) => {
    // 获取客户端提交到服务器的用户信息
    const userinfo = req.body;
    console.log('userinfo--', userinfo);
    // 对表单中的数据，进行合法性校验
    if (!userinfo.username || !userinfo.password) {
        return res.send({
            status: 1,
            message: '用户名或密码不合法！'
        });
    }

    // 4.2 定义sql语句，查询用户名是否被占用
    const sqlStr = 'SELECT * FROM ev_users WHERE username = ?';
    db.query(sqlStr, userinfo.username, (err, results) => {
        // 执行sql语句失败
        if (err) return res.send({ status: 1, message: err.message });
        // 判断用户名是否被占用
        if (results.length > 0) {
            return res.send({ status: 1, message: '用户名已被占用！请更换用户名！' });
        };


        // 用户名可以使用，继续后续逻辑
        // TODO: 插入新用户到数据库
        // 5.2 调用 bcrypt.hashSync([明文密码], [随机值长度])对密码进行加密，返回加密密码
        console.log('userinfo1--',userinfo); // { username: 'lisi', password: '000000' }
        userinfo.password = bcrypt.hashSync(userinfo.password, 10);
        console.log('userinfo2--',userinfo); // {username: 'lisi', password: '$2a$10$xZKeRqhTyGPUwZ9oWvAvg.f5XZKJZt1fsizgF0nut5.QkGbXyoDCe'}
        
        const insertSql = 'INSERT INTO ev_users (username, password) VALUES (?, ?)';
        db.query(insertSql, [userinfo.username, userinfo.password], (err, insertResults) => {
            if (err) return res.send({ status: 1, message: err.message });
            // insertResults.affectedRows 影响行数
            if (insertResults.affectedRows !== 1) {
                return res.send({ status: 1, message: '注册失败！' });
            }
            res.send({ status: 0, message: '注册成功！' });
        });
    });
};

// 登录接口处理函数
const login =  (req, res) => {
    res.send('login OK');
};

export default {regUser, login};
```
6. 代码优化：将res.send的多种情况封装起来
在处理函数中，需要多次调用res.send()向客户端响应处理失败的结果，为了简化代码，可以手动封装一个
res.cc()函数
（1）在app.js中，所有路由之前，声明一个全局中间件，为res对象挂载一个res.cc()函数：
```js
import express from 'express'
import cors from 'cors' // 跨域中间件cors
import useRouter from './router/user.js'; // 导入路由

const app = express();

// 配置跨域cors
app.use(cors());
// 配置解析application/x-www-form-urlcoded 格式的表单数据中间件
app.use(express.urlencoded({ extended: false }));

// 6.1 在路由之前，声明一个全局中间件，为res对象挂载一个res.cc()函数,两个参数err,status
app.use((req, res, next) => {
    // status = 0为成功；= 1 为失败；默认status的值为1
    res.cc = (err, status = 1) => {
        res.send({
            status,
            message: err instanceof Error ? err.message : err
        })
    };

    next();
})


// 注册路由
app.use('/api', useRouter);

app.listen(3007, '127.0.0.1', () => {
    console.log('express sever running at 127.0.0.1:3007');
})
```
（2）在使用res.send()的地方，调用res.cc()
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'
// 5.1 导入 bcryptjs 加密插件
import bcrypt from 'bcryptjs' 

// 注册新用户接口处理函数
const regUser = (req, res) => {
    // 获取客户端提交到服务器的用户信息
    const userinfo = req.body;
    console.log('userinfo--', userinfo);
    // 对表单中的数据，进行合法性校验
    if (!userinfo.username || !userinfo.password) {
        return res.send({
            status: 1,
            message: '用户名或密码不合法！'
        });
    }

    // 4.2 定义sql语句，查询用户名是否被占用
    const sqlStr = 'SELECT * FROM ev_users WHERE username = ?';
    db.query(sqlStr, userinfo.username, (err, results) => {
        // 执行sql语句失败
        // 6.2 使用封装好的res.cc()函数来替换res.send()
        // if (err) return res.send({ status: 1, message: err.message });
        if (err) return res.cc(err);
        // 判断用户名是否被占用
        if (results.length > 0) {
            // 6.2 使用封装好的res.cc()函数来替换res.send()
            // return res.send({ status: 1, message: '用户名已被占用！请更换用户名！' });
            return res.cc('用户名已被占用！请更换用户名！' );
        };


        // 用户名可以使用，继续后续逻辑
        // TODO: 插入新用户到数据库
        // 5.2 调用 bcrypt.hashSync([明文密码], [随机值长度])对密码进行加密，返回加密密码
        console.log('userinfo1--',userinfo); // { username: 'lisi', password: '000000' }
        userinfo.password = bcrypt.hashSync(userinfo.password, 10);
        console.log('userinfo2--',userinfo); // {username: 'lisi', password: '$2a$10$xZKeRqhTyGPUwZ9oWvAvg.f5XZKJZt1fsizgF0nut5.QkGbXyoDCe'}

        const insertSql = 'INSERT INTO ev_users (username, password) VALUES (?, ?)';
        db.query(insertSql, [userinfo.username, userinfo.password], (err, insertResults) => {
            // 6.2 使用封装好的res.cc()函数来替换res.send()
            // if (err) return res.send({ status: 1, message: err.message });
            if (err) return res.cc(err);
            // insertResults.affectedRows 影响行数
            if (insertResults.affectedRows !== 1) {
                // 6.2 使用封装好的res.cc()函数来替换res.send()
                // return res.send({ status: 1, message: '注册失败！' });
                return res.cc('注册失败！' );
            }
            // 6.2 使用封装好的res.cc()函数来替换res.send()
            // res.send({ status: 0, message: '注册成功！' });
            res.cc('注册成功！' ,0);
        });
    });
};

// 登录接口处理函数
const login =  (req, res) => {
    res.send('login OK');
};

export default {regUser, login};
```
7. 优化表单数据验证
表单验证的原则：前端验证为铺，后端验证为主，后端永远不要相信前端提交过来的任何内容。

单纯的使用if...else...,的形式对数据合法性进行验证，效率低下、出错率高、维护性差。
因此，推荐使用第三方数据验证模块，来降低出错率、提高验证的效率与可维护性，让后端程序员把更多的精力放在核心业务逻辑的处理上
（1）安装 joi 包，为表单中携带的每个数据项，定义验证规则：`npm i joi`
（2）安装 @escook/express-joi 中间件，来实现自动对表单数据进行验证的功能：`npm i @escook/express-joi`
（3）新建 /schema/user.js 用户信息验证规则模块，并初始化代码如下：
```js
/**
 * 文件: /schema/user.js
 * 这里定义用户注册规则并自动验证
 */

import joi from 'joi'

/**
 * string()值必须是字符串
 * alphanum()值只能是包含a-zA-Z0-9的字符串
 * min([length])最小长度
 * max([length])最大长度
 * required()值是必填项，不能为undefined
 * pattern([正则表达式])值必须符合正则表达式的规则
 */

// 定义用户名和密码的验证规则
const username = joi.string().alphanum().min(1).max(10).required();
const password = joi.string().pattern(/^[\S]{6,12}$/).required();

// 定义验证注册和登录表单数据的规则对象
export const  reg_login_schema = {
    // 验证注册登录请求中的body里的数据
    body: {
        username,
        password,
    }
}
```
（4）在路由定义函数/router/user.js中，导入验证表单数据的中间件及需要的验证规则对象
```js
/**
 * 文件: /router/user.js
 * 这里定义用户相关路由
 */

import express from 'express'
import userHandle from '../router_handle/user.js';
// 7.4.1 导入验证表单的中间件
import expressJoi from '@escook/express-joi';
// 7.4.2 导入需要的验证规则对象
import {reg_login_schema} from '../schema/user.js'


const router = express.Router();

// 注册新用户接口
// 7.4.3 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证
// 数据验证成功后，会把这次请求流转给后面的路由处理函数
// 数据验证失败后，终止后续代码的执行，并抛出一个全局的Error错误，进入全局错误级别中间件进行处理
router.post('/reguser',expressJoi(reg_login_schema), userHandle.regUser);

// 用户登录接口
router.post('/login', userHandle.login);

export default router;

```
（5）在app.js中定义全局错误级别中间件，捕获验证失败的错误，并把验证失败的结果响应给客户端
```js
/**
 * 文件: app.js
 * 项目入口文件，创建express服务器，定义中间件，注册路由...
 */
import express from 'express'
import cors from 'cors' // 跨域中间件cors
import useRouter from './router/user.js'; // 导入路由
import joi from 'joi';

const app = express();

// 配置跨域cors
app.use(cors());
// 配置解析application/x-www-form-urlcoded 格式的表单数据中间件
app.use(express.urlencoded({ extended: false }));

// 6.1 在路由之前，声明一个全局中间件，为res对象挂载一个res.cc()函数,两个参数err,status
app.use((req, res, next) => {
    // status = 0为成功；= 1 为失败；默认status的值为1
    res.cc = (err, status = 1) => {
        res.send({
            status,
            message: err instanceof Error ? err.message : err
        })
    };

    next();
})


// 注册路由
app.use('/api', useRouter);

// 7.5 全局错误级别中间件
app.use((err, req, res, next) => {
    // 数据验证失败
    if(err instanceof joi.ValidationError) return res.cc(err);
    // 未知错误
    res.cc(err);
})

app.listen(3007, '127.0.0.1', () => {
    console.log('express sever running at 127.0.0.1:3007');
})
```

8. 登录
（1）检测表单数据是否合法
```js
/**
 * 文件: /router/user.js
 * 这里定义用户相关路由
 */

import express from 'express'
import userHandle from '../router_handle/user.js';
// 7.4.1 导入验证表单的中间件
import expressJoi from '@escook/express-joi';
// 7.4.2 导入需要的验证规则对象
import {reg_login_schema} from '../schema/user.js'


const router = express.Router();

// 注册新用户接口
// 7.4.3 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证
// 数据验证成功后，会把这次请求流转给后面的路由处理函数
// 数据验证失败后，终止后续代码的执行，并抛出一个全局的Error错误，进入全局错误级别中间件进行处理
router.post('/reguser',expressJoi(reg_login_schema), userHandle.regUser);

// 8.1 用户登录接口，对当前请求中携带的数据进行验证
router.post('/login', expressJoi(reg_login_schema), userHandle.login);

```
（2）根据用户名查询用户数据
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'
// 5.1 导入 bcryptjs 加密插件
import bcrypt from 'bcryptjs' 

// 注册新用户接口处理函数
const regUser = (req, res) => {
    // 获取客户端提交到服务器的用户信息
    const userinfo = req.body;
    console.log('userinfo--', userinfo);
    // 对表单中的数据，进行合法性校验
    // if (!userinfo.username || !userinfo.password) {
    //     return res.send({
    //         status: 1,
    //         message: '用户名或密码不合法！'
    //     });
    // }
    // 7.1上面这段验证已经使用中间件@escook/express-joi来验证了

    // 4.2 定义sql语句，查询用户名是否被占用
    const sqlStr = 'SELECT * FROM ev_users WHERE username = ?';
    db.query(sqlStr, userinfo.username, (err, results) => {
        // 执行sql语句失败
        // 6.2 使用封装好的res.cc()函数来替换res.send()
        // if (err) return res.send({ status: 1, message: err.message });
        if (err) return res.cc(err);
        // 判断用户名是否被占用
        if (results.length > 0) {
            // 6.2 使用封装好的res.cc()函数来替换res.send()
            // return res.send({ status: 1, message: '用户名已被占用！请更换用户名！' });
            return res.cc('用户名已被占用！请更换用户名！' );
        };


        // 用户名可以使用，继续后续逻辑
        // TODO: 插入新用户到数据库
        // 5.2 调用 bcrypt.hashSync([明文密码], [随机值长度])对密码进行加密，返回加密密码
        console.log('userinfo1--',userinfo); // { username: 'lisi', password: '000000' }
        userinfo.password = bcrypt.hashSync(userinfo.password, 10);
        console.log('userinfo2--',userinfo); // {username: 'lisi', password: '$2a$10$xZKeRqhTyGPUwZ9oWvAvg.f5XZKJZt1fsizgF0nut5.QkGbXyoDCe'}

        const insertSql = 'INSERT INTO ev_users (username, password) VALUES (?, ?)';
        db.query(insertSql, [userinfo.username, userinfo.password], (err, insertResults) => {
            // 6.2 使用封装好的res.cc()函数来替换res.send()
            // if (err) return res.send({ status: 1, message: err.message });
            if (err) return res.cc(err);
            // insertResults.affectedRows 影响行数
            if (insertResults.affectedRows !== 1) {
                // 6.2 使用封装好的res.cc()函数来替换res.send()
                // return res.send({ status: 1, message: '注册失败！' });
                return res.cc('注册失败！' );
            }
            // 6.2 使用封装好的res.cc()函数来替换res.send()
            // res.send({ status: 0, message: '注册成功！' });
            res.cc('注册成功！',0 );
        });
    });
};

// 登录接口处理函数
const login =  (req, res) => {
    // 8.2 根据用户名查询用户数据
    const userinfo = req.body; // 接收表单数据
    const sql = `select * from ev_users where username = ?`;
    db.query(sql, userinfo.username, (err, results) => {
        // 执行sql失败
        if(err) return res.cc(err);
        // 执行sql成功，但获取到的数据条数不等于1
        if(results.length !== 1) return res.cc('登录失败');
        // TODO: 判断密码是否正确
        res.send('login OK');

    })

    
};

export default {regUser, login};
```
（3）判断用户输入的密码是否正确
核心实现思路：调用bcrypt.compareSync(用户提交的密码，数据库中的密码)方法比较密码是否一致
返回值是布尔值(true一致、false不一致)
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'
// 5.1 导入 bcryptjs 加密插件
import bcrypt from 'bcryptjs' 


// 登录接口处理函数
const login =  (req, res) => {
    // 8.2 根据用户名查询用户数据
    const userinfo = req.body; // 接收表单数据
    const sql = `select * from ev_users where username = ?`;
    db.query(sql, userinfo.username, (err, results) => {
        // 执行sql失败
        if(err) return res.cc(err);
        // 执行sql成功，但获取到的数据条数不等于1
        if(results.length !== 1) return res.cc('登录失败');
        
        // 8.3 判断用户密码是否正确,bcrypt.compareSync()判断用户提交的密码和数据库中存的加密密码是否一致
        const compareResult = bcrypt.compareSync(userinfo.password, results[0].password);
        if(!compareResult) {
            return res.cc('密码错误，登录失败！')
        } else {
            // return res.send('login OK');

            // TODO: 登录成功，生成Token字符串
        }
    })

};

export default {regUser, login};
```
（4）生成JWT的Token字符串
8.4.1 核心注意点：在生成Token宇符串的时候，一定要别除密码和头像的值
8.4.2 安装生成token字符串的包：npm i jsonwebtoken@8.5.1
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'
// 5.1 导入 bcryptjs 加密插件
import bcrypt from 'bcryptjs' 
// 8.4.2 导入生成token的包
import jwt from 'jsonwebtoken'

// 登录接口处理函数
const login =  (req, res) => {
    // 8.2 根据用户名查询用户数据
    const userinfo = req.body; // 接收表单数据
    const sql = `select * from ev_users where username = ?`;
    db.query(sql, userinfo.username, (err, results) => {
        // 执行sql失败
        if(err) return res.cc(err);
        // 执行sql成功，但获取到的数据条数不等于1
        if(results.length !== 1) return res.cc('登录失败');
        
        // 8.3 判断用户密码是否正确,bcrypt.compareSync()判断用户提交的密码和数据库中存的加密密码是否一致
        const compareResult = bcrypt.compareSync(userinfo.password, results[0].password);
        if(!compareResult) {
            return res.cc('密码错误，登录失败！')
        } else {
            // return res.send('login OK');

            // TODO: 登录成功，生成Token字符串

            /*8.4.1剔除密码和头像的值, ...是扩展符，后面的password会覆盖前面的值*/
            const user = {...results[0], password: '', user_pic: ''};
            console.log('user--', user);
        }
    })

};

```
8.4.3 项目根目录下新建config.js文件：
```js
/**
 * 文件: config.js
 * 这里是全局配置文件
 */

export const config = {
    // 加密和解密token的密钥
    jwtSecretKey: 'ittttt',
    // token有效期
    expiresIn: '10h',
}
```
8.4.4 对用户信息进行加密，生成token字符串，将全局文件config.js文件导入
```js
/**
 * 文件: /router_handle/user.js
 * 这里定义用户相关路由模块函数，供/router/user.js模块调用
 */

// 4.1导入数据库
import db from '../db/index.js'
// 5.1 导入 bcryptjs 加密插件
import bcrypt from 'bcryptjs' 
// 8.4.2 导入生成token的包
import jwt from 'jsonwebtoken'
// 8.4.3 导入全局的配置文件
import {config} from '../config.js'


// 登录接口处理函数
const login =  (req, res) => {
    // 8.2 根据用户名查询用户数据
    const userinfo = req.body; // 接收表单数据
    const sql = `select * from ev_users where username = ?`;
    db.query(sql, userinfo.username, (err, results) => {
        // 执行sql失败
        if(err) return res.cc(err);
        // 执行sql成功，但获取到的数据条数不等于1
        if(results.length !== 1) return res.cc('登录失败');
        
        // 8.3 判断用户密码是否正确,bcrypt.compareSync()判断用户提交的密码和数据库中存的加密密码是否一致
        const compareResult = bcrypt.compareSync(userinfo.password, results[0].password);
        if(!compareResult) {
            return res.cc('密码错误，登录失败！')
        } else {
            // return res.send('login OK');

            // TODO: 登录成功，生成Token字符串

            /*8.4.1剔除密码和头像的值, ...是扩展符，后面的password会覆盖前面的值*/
            const user = {...results[0], password: '', user_pic: ''};
            console.log('user--', user);
            // 8.4.4 对用户信息进行加密，生成token字符串
            const tokenStr = jwt.sign(user, config.jwtSecretKey, {expiresIn: config.expiresIn});
            // 调用res.send()将token响应给客户端
            res.send({
                status: 0,
                message: '登录成功',
                token: 'Bearer' + tokenStr
            })
            /**
             * 客户端收到：
             * {
                "status": 0,
                "message": "登录成功",
                "token": "BearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywidXNlcm5hbWUiOiJsaXh1ZSIsInBhc3N3b3JkIjoiIiwibmlja25hbWUiOm51bGwsImVtYWlsIjpudWxsLCJ1c2VyX3BpYyI6IiIsImlhdCI6MTc1MjY2MjE3OCwiZXhwIjoxNzUyNjk4MTc4fQ.E44r6SKJ6OWoYchfcQsFXJBIIOTWHOb_qTtHjVZ0vXY"
                }
             */
        }

    })

    
};

```
9. 配置解析token的中间件，接口token验证
（1）安装解析token的中间件： npm i express-jwt@5.3.3
（2）在app.js中注册路由之前，配置解析token的中间件
```js
/**
 * 文件: app.js
 * 项目入口文件，创建express服务器，定义中间件，注册路由...
 */
import express from 'express'
import cors from 'cors' // 跨域中间件cors
import useRouter from './router/user.js'; // 导入路由
import joi from 'joi'; // 导入定义验证规则中间件joi
import {config} from './config.js' // 导入全局配置文件
import expressJWT from 'express-jwt' // 导入解析token的中间件

const app = express();

// 配置跨域cors
app.use(cors());
// 配置解析application/x-www-form-urlcoded 格式的表单数据中间件
app.use(express.urlencoded({ extended: false }));

// 6.1 在路由之前，声明一个全局中间件，为res对象挂载一个res.cc()函数,两个参数err,status
app.use((req, res, next) => {
    // status = 0为成功；= 1 为失败；默认status的值为1
    res.cc = (err, status = 1) => {
        res.send({
            status,
            message: err instanceof Error ? err.message : err
        })
    };

    next();
})


// 9.2 在路由配置之前，使用.unless({path: [/^\/api\//]}) 指定哪些接口不需要进行token身份认证
app.use(expressJWT({secret: config.jwtSecretKey }).unless({ path: [/^\/api\//] }));


// 注册路由
app.use('/api', useRouter);

// 7.5 全局错误级别中间件
app.use((err, req, res, next) => {
    // 数据验证失败
    if(err instanceof joi.ValidationError) return res.cc(err);
    // 未知错误
    res.cc(err);
})

app.listen(3007, '127.0.0.1', () => {
    console.log('express sever running at 127.0.0.1:3007');
})
```
（3）在app.js的错误级别中间件里，捕获并处理token认证失败后的错误
```js
// 7.5 全局错误级别中间件
app.use((err, req, res, next) => {
    // 数据验证失败
    if(err instanceof joi.ValidationError) return res.cc(err);

    // 9.3  捕获身份认证失败的错误
    if (err.name === 'UnauthorizedError' ) return res.cc('身份认证失败！');
    // 未知错误
    res.cc(err);
})

```

### 3. 个人中心
1. 获取用户基本信息
get请求url: /my/userinfo, 请求头里要带token
（1）新建/router/userinfo.js 路由模块和router_handle/userinfo.js
```js
/**
 * 文件: /router/userinfo.js
 * 这里定义个人中心路由模块函数
 */
import express from 'express'
import {getUserinfo} from '../router_handle/userinfo.js'

// 创建express路由对象
const router = express.Router();

// 获取用户基本信息
router.get('/userinfo', getUserinfo)

export default router;
```

```js
/**
 * 文件: /router_handle/userinfo.js
 * 这里定义获取用户信息相关路由模块函数，供/router/userinfo.js模块调用
 */

const getUserinfo = (req, res) => {
    res.send('ok');
}

export {getUserinfo};
```
（2）在app.js中注册路由
```js
/**
 * 文件: app.js
 * 项目入口文件，创建express服务器，定义中间件，注册路由...
 */
import userinfoRouter from './router/userinfo.js' // 导入个人中心路由模块

// 注册路由
app.use('/my', userinfoRouter); // 注册个人中心路由模块，以'/my'开头的接口

/*
客户端发送get请求：127.0.0.1:3007/my/userinfo
Header中：Authorization ：Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywidXNlcm5hbWUiOiJsaXh1ZSIsInBhc3N3b3JkIjoiIiwibmlja25hbWUiOm51bGwsImVtYWlsIjpudWxsLCJ1c2VyX3BpYyI6IiIsImlhdCI6MTc1Mjc0MjE5MiwiZXhwIjoxNzUyNzc4MTkyfQ.7IeVv2UNu50WBERlmJeQPE34Nl029pIlpPkDfVZE1uk
*/
```
（3）获取用户基本信息，在/router_handle/userinfo.js中处理
```js
/**
 * 文件: /router_handle/userinfo.js
 * 这里定义获取用户信息相关路由模块函数，供/router/userinfo.js模块调用
 */
import db from '../db/index.js'; // 导入数据库模块


const getUserinfo = (req, res) => {
    const sql = `select id, username, nickname, email, user_pic from ev_users where id = ?`;
    db.query(sql, req.user.id, (err, results) => {
        // 执行sql失败
        if(err) return res.cc(err);
        // 执行sql成功但获取条数不等于1
        if(results.length !== 1) return res.cc('获取用户信息失败');
        // 获取成功后将用户信息响应给客户端
        res.send({
            status: 0,
            message: '获取用户信息成功',
            data: results[0]
        });
        /**比如成功响应客户端：
         * {
            "status": 0,
            "message": "获取用户信息成功",
            "data": {
                "id": 3,
                "username": "lixue",
                "nickname": null,
                "email": null,
                "user_pic": null
            }
          }
         */
    })
    
}

export {getUserinfo}
```

2. 更新用户基本信息
post请求url: /my/userinfo, , 请求头里要带token
（1）定义 id, email， nickname的验证规则
```js
/**
 * 文件: /schema/user.js
 * 这里定义用户注册规则并自动验证
 */
// 定义验证规则中间件joi
import joi from 'joi'

/**
 * string()值必须是字符串
 * alphanum()值只能是包含a-zA-Z0-9的字符串
 * min([length])最小长度
 * max([length])最大长度
 * required()值是必填项，不能为undefined
 * pattern([正则表达式])值必须符合正则表达式的规则
 */

// 定义用户名和密码的验证规则
const username = joi.string().alphanum().min(1).max(10).required();
const password = joi.string().pattern(/^[\S]{6,12}$/).required();

// 2.1 定义 id, email， nickname的验证规则
const id = joi.number().integer().min(1).required();
const nickname = joi.string().required();
const user_email = joi.string().email().required();

// 定义验证注册和登录表单数据的规则对象
export const  reg_login_schema = {
    // 验证注册登录请求中的body里的数据
    body: {
        username,
        password,
    }
}

// 2.1 定义验证规则对象--更新用户基本信息
export const update_userinfo_schema = {
    // 验证更新用户基本信息请求中req的body里的数据
    body: {
        id: id,
        nickname: nickname,
        email: user_email
    }
}
```
（2）将验证规则放进接口请求的中间件里
```js
/**
 * 文件: /router/userinfo.js
 * 这里定义个人中心路由模块函数
 */
import express from 'express'
import {getUserinfo, updateUserInfo} from '../router_handle/userinfo.js'
import expressJoi from '@escook/express-joi'; // 导入验证表单的中间件
import {update_userinfo_schema} from '../schema/user.js' // 导入需要的验证规则对象

// 创建express路由对象
const router = express.Router();

// 获取用户基本信息
router.get('/userinfo', getUserinfo);
// 2.2 更新用户基本信息, 添加接口请求中间件验证数据规则
router.post('/userinfo', expressJoi(update_userinfo_schema) , updateUserInfo);

export default router;

```
（3）编写更新用户基本信息的处理函数
```js
/**
 * 文件: /router_handle/userinfo.js
 * 这里定义获取用户信息相关路由模块函数，供/router/userinfo.js模块调用
 */
import db from '../db/index.js'; // 导入数据库模块

// 更新用户信息
const updateUserInfo = (req, res) => {
    const sql = `update ev_users set ? where id = ?`;
    // 执行sql
    db.query(sql, [req.body, req.body.id], (err, results) => {
        if(err) return res.cc(err);
        if(results.affectedRows !== 1) return res.cc('更新用户的基本信息失败！');
        res.cc('更新用户信息成功', 0);
    })
    
}

export {getUserinfo, updateUserInfo}


/*
客户端post请求: 127.0.0.1:3007/my/userinfo, 请求头里要带token
body里填写id, nickname,email
*/
```

3. 重置密码
客户端post请求: 127.0.0.1:3007/my/updatepwd, 请求头里要带token
body里填写id, username, password
（1）添加重置密码接口
```js
/**
 * 文件: /router/userinfo.js
 * 这里定义个人中心路由模块函数
 */
import express from 'express'
import {getUserinfo, updateUserInfo, updatePassword} from '../router_handle/userinfo.js'
import expressJoi from '@escook/express-joi';
// 导入需要的验证规则对象
import {update_userinfo_schema} from '../schema/user.js'

// 创建express路由对象
const router = express.Router();

// 获取用户基本信息
router.get('/userinfo', getUserinfo);
// 更新用户基本信息, 添加接口请求中间件验证数据规则
router.post('/userinfo', expressJoi(update_userinfo_schema) , updateUserInfo);
// 3.1 重置密码
router.post('/updatepwd', updatePassword)

export default router;
```

```js
/**
 * 文件: /router_handle/userinfo.js
 * 这里定义获取用户信息相关路由模块函数，供/router/userinfo.js模块调用
 */
import db from '../db/index.js'; // 导入数据库模块

// 重置密码
const updatePassword = (req, res) => {
    res.send('ok');
}

export {getUserinfo, updateUserInfo, updatePassword}
```

（2）添加密码验证规则
```js
/**
 * 文件: /schema/user.js
 * 这里定义用户注册规则并自动验证
 */
// 定义验证规则中间件joi
import joi from 'joi'

/**
 * string()值必须是字符串
 * alphanum()值只能是包含a-zA-Z0-9的字符串
 * min([length])最小长度
 * max([length])最大长度
 * required()值是必填项，不能为undefined
 * pattern([正则表达式])值必须符合正则表达式的规则
 */

// 定义用户名和密码的验证规则
const username = joi.string().alphanum().min(1).max(10).required();
const password = joi.string().pattern(/^[\S]{6,12}$/).required();

// 定义 id, email， nickname的验证规则
const id = joi.number().integer().min(1).required();
const nickname = joi.string().required();
const user_email = joi.string().email().required();




// 定义验证注册和登录表单数据的规则对象
export const  reg_login_schema = {
    // 验证注册登录请求中的body里的数据
    body: {
        username,
        password,
    }
}

// 2.1 定义验证规则对象--更新用户基本信息
export const update_userinfo_schema = {
    // 验证更新用户基本信息请求中req的body里的数据
    body: {
        id: id,
        nickname: nickname,
        email: user_email
    }
}

// 3.2 定义验证规则对象--重置密码
export const update_password_schema = {
    // 验证body的数据规则
    body: {
        oldPwd: password, // 使用password这个验证规则
        //  joi.not(joi.ref('oldPwd'))表示新密码不可与旧密码相同，
        // .concat(password) 表示 用于合并 joi.not(joi.ref('oldPwd')) 和 password这两条验证规则
        newPwd: joi.not(joi.ref('oldPwd')).concat(password)
    }
}
```
（3）将密码验证规则添加进接口请求中间件
```js
/**
 * 文件: /router/userinfo.js
 * 这里定义个人中心路由模块函数
 */
import express from 'express'
import {getUserinfo, updateUserInfo, updatePassword} from '../router_handle/userinfo.js'
import expressJoi from '@escook/express-joi';
// 3.3 导入需要的验证规则对象
import {update_userinfo_schema, update_password_schema} from '../schema/user.js'

// 创建express路由对象
const router = express.Router();

// 获取用户基本信息
router.get('/userinfo', getUserinfo);
// 更新用户基本信息, 添加接口请求中间件验证数据规则
router.post('/userinfo', expressJoi(update_userinfo_schema) , updateUserInfo);
// 3.3 重置密码, 添加接口请求中间件验证数据规则
router.post('/updatepwd', expressJoi(update_password_schema), updatePassword)

export default router;
```
（4）使用sql重置数据库中用户密码
```js
/**
 * 文件: /router_handle/userinfo.js
 * 这里定义获取用户信息相关路由模块函数，供/router/userinfo.js模块调用
 */
import db from '../db/index.js'; // 导入数据库模块
import bcrypt from 'bcryptjs' // 导入 bcryptjs 加密插件


// 重置密码
const updatePassword = (req, res) => {
    const sql = `select * from ev_users where id = ?`
    db.query(sql, req.user.id, (err, results) => {
        if(err) return res.cc(err);
        if(results.length !== 1 ) return res.cc('用户不存在！');

        // 判断提交的旧密码是否正确
        const compareResult = bcrypt.compareSync(req.body.oldPwd, results[0].password);
        if(!compareResult) return res.cc('原密码错误！');

        // 对新密码加密后更新到数据库
        const updatePwdSql = `update ev_users set password = ? where id = ?`;
        const newPwd = bcrypt.hashSync(req,body,newPwd, 10); // 新密码加密
        db.query(updatePwdSql, [newPwd, req.user.id], (err, results) => {
            if(err) return res.cc(err);
            if(results.affectedRows !== 1) return res.cc('更新密码失败！');
            res.cc('更新密码成功!', 0);
        })
    })
    // res.send('ok');
}

export {getUserinfo, updateUserInfo, updatePassword}


/*
客户端post请求: 127.0.0.1:3007/my/userinfo, 请求头里要带token
body里填写oldPwd, newPwd
*/

```

4. 更换头像
客户端post请求: 127.0.0.1:3007/my/update/avatar, 请求头里要带token
body里填写
（1）定义头像数据验证规则
```js
/**
 * 文件: /schema/user.js
 * 这里定义用户注册规则并自动验证
 */
// 定义验证规则中间件joi
import joi from 'joi'

/**
 * string()值必须是字符串
 * alphanum()值只能是包含a-zA-Z0-9的字符串
 * min([length])最小长度
 * max([length])最大长度
 * required()值是必填项，不能为undefined
 * pattern([正则表达式])值必须符合正则表达式的规则
 */

// 定义用户名和密码的验证规则
const username = joi.string().alphanum().min(1).max(10).required();
const password = joi.string().pattern(/^[\S]{6,12}$/).required();

// 定义 id, email， nickname的验证规则
const id = joi.number().integer().min(1).required();
const nickname = joi.string().required();
const user_email = joi.string().email().required();
// 4.2 定义 头像avatar 的验证规则
//dataUri()指的是如下格式的字符串数据：data:image/png;base64,VE9PTUFOWVNFQ1JFVFM=
const avatar = joi.string().dataUri().required();


// 定义验证注册和登录表单数据的规则对象
export const  reg_login_schema = {
    // 验证注册登录请求中的body里的数据
    body: {
        username,
        password,
    }
}

// 定义验证规则对象--更新用户基本信息
export const update_userinfo_schema = {
    // 验证更新用户基本信息请求中req的body里的数据
    body: {
        id: id,
        nickname: nickname,
        email: user_email
    }
}

// 定义验证规则对象--重置密码
export const update_password_schema = {
    // 验证body的数据规则
    body: {
        oldPwd: password, // 使用password这个验证规则
        //  joi.not(joi.ref('oldPwd'))表示新密码不可与旧密码相同，
        // .concat(password) 表示 用于合并 joi.not(joi.ref('oldPwd')) 和 password这两条验证规则
        newPwd: joi.not(joi.ref('oldPwd')).concat(password)
    }
}

// 4.2 定义 头像avatar 的验证规则对象
export const update_avatar_schema = {
    body: {
        avatar: avatar
    }
}
```

（2）添加更换头像接口,将验证规则放进接口请求的中间件里
```js
/**
 * 文件: /router/userinfo.js
 * 这里定义个人中心路由模块函数
 */
import express from 'express'
import {getUserinfo, updateUserInfo, updatePassword, updateAvatar} from '../router_handle/userinfo.js'
import expressJoi from '@escook/express-joi';
// 导入需要的验证规则对象
import {update_userinfo_schema, update_password_schema, update_avatar_schema} from '../schema/user.js'

// 创建express路由对象
const router = express.Router();

// 获取用户基本信息
router.get('/userinfo', getUserinfo);
// 更新用户基本信息, 添加接口请求中间件验证数据规则
router.post('/userinfo', expressJoi(update_userinfo_schema) , updateUserInfo);
// 重置密码, 添加接口请求中间件验证数据规则
router.post('/updatepwd', expressJoi(update_password_schema), updatePassword);
// 更换头像
router.post('/update/avatar', expressJoi(update_avatar_schema), updateAvatar);

export default router;
```

（3）使用sql重置数据库中头像
```js
/**
 * 文件: /router_handle/userinfo.js
 * 这里定义获取用户信息相关路由模块函数，供/router/userinfo.js模块调用
 */
import db from '../db/index.js'; // 导入数据库模块
import bcrypt from 'bcryptjs' // 导入 bcryptjs 加密插件

/**
 * 更换头像处理函数
 */
const updateAvatar = (req, res) => {
    const sql = `update ev_users set user_pic = ? where id = ?`;
    db.query(sql, [req.body.avatar, req.user.id], (err, results) => {
        if(err) return res.cc(err);
        if(results.affectedRows !== 1) return res.cc('更新头像失败！');

        return res.cc('更新头像成功！');
    })
    // res.send('ok');
}

export {getUserinfo, updateUserInfo, updatePassword, updateAvatar}
```

### 4. 文章类别管理
### 5. 文章管理








